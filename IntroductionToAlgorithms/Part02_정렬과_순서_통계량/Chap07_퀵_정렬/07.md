# 7 퀵 정렬
퀵 정렬
* 원소 수가 n개인 배열을 최악의 경우 O(n^2)에 정렬하는 알고리즘
* 평균적인 경우 O(n lg n)으로 매우 효율적이고 상수 인자도 매우 작다.
* 내부 정렬이라는 장점
* 가상 메모리 환경에서도 잘 동작해 일반적으로 실제 문제에서 가장 유용한 정렬 방법

## 7.1 퀵 정렬
병합 정렬과 마찬가지로 분할정복에 기반을 둔다.

배열 A[p..r]을 처리하는 3단계 분할 정복 과정
* 분할 : 배열 A[p..r]을 두 개의 부분 배열 A[p..q-1]과 A[q+1..r]로 분할(재배치)
  * A[p..q-1]에는 A[q]보다 작거나 같은 원소
  * A[q+1..r]에는 A[q]보다 크거나 같은 원소를 배치
  * 양쪽 부분 배열 중 한 쪽에는 아무 원소도 없을 수 있다.
  * 위의 분할 과정을 위한 인덱스 q를 계산한다.
* 정복 : 퀵 정렬을 재귀 호출해서 두 부분 배열을 정렬한다.
* 결합 : 부분 배열이 이미 정렬되어 있으므로 따로 합치는 작업을 할 필요가 없다.
  * 전체 배열 A[p..r]이 이미 정렬되어 있기 때문

퀵 정렬을 구현한 프로시저
~~~C++
QUICKSORT(A, p, r)
1:  if p < r
2:      q = PARTITION(A, p, r)
3:      QUICKSORT(A, p, q - 1)
4:      QUICKSORT(A, q + 1, r)
~~~
* 전체 배열 A를 정렬하려면 QUICKSORT(A, 1, A.length)를 호출하면 된다.

배열 분할 프로시저
* 이 알고리즘의 핵심 부분은 부분 배열 A[p..r]을 내부에서 재배치하는 PARTITION 프로시저

~~~C++
PARTITION(A, p, r)
1:  X = A[r]
2:  i = p - 1
3:  for j = p to r - 1
4:      if A[j] <= x
5:          i = i + 1
6:          A[i] <-> A[j]
7:  A[i + 1] <-> A[r]
8:  return i + 1
~~~

PARTITION의 동작

![chap07-01](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/ee5d5395-5b31-4520-a362-8f6dac01e7a3)


3-6 행 루프를 시작할 때마다 모든 배열 인덱스 k에 대해 다음과 같다.
1. p <= k <= i이면 A[k] <= x다.
2. i + 1 <= k <= j - 1 이면 A[k] > x다.
3. k = r이면 A[k] = x다.

이 구조를 요약하면

![chap07-02](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/5efb1124-d1aa-4b97-9388-546c3827eae4)
* j와 r - 1 사이에 있는 인덱스는 세 가지 경우의 조건들 중 어느것도 만족하지 않고
* 이 구간의 값들은 기준 x와 어떤 관계인지 아직 파악되지 않은 상태

루프 불변성 증명
* 초기조건 : 루프를 처음 반복하기 전에 i = p - 1이고 j = p다.
  * p와 i 사이에는 아무런  값이 없고, i + 1과 j - 1 사이에도 아무런 값이 없으므로 루프 불변성의 처음 두 특성은 자명하게 만족한다.
  * 1행에 있는 할당문이 세 번째 특성을 만족한다.
* 유지조건 : 4행에 있는 검사 결과에 따라서 두 가지 경우를 고려해야 한다.
  * A[j] > x일 때는 루프에서 하는 일은 j를 증가시키는 것뿐
  * j가 증가한 다음에도 추가된 A[j - 1]에 대해 두 번째 특성을 만족하고 나머지 부분은 변하지 않음
  * A[j] <= x인 경우 i가 증가하고 A[i]와 A[j]가 서로 바뀐 다음 j가 증가함
  * A[i] <= x가 되므로 첫 번째 특성을 만족한다.
  * 비슷한 논리로 A[j - 1]에 교환되어 들어간 값은 루프 불변성에 따라 x보다 크므로 A[j - 1] > x를 만족
* 종료조건 : 종료하는 시점에서 j = r이다.
  * 따라서 배열의 모든 원소들은 루프 불변성의 세 가지 경우 중 하나에 해당
  * 배열의 값은 x보다 작거나 같은 집합, x보다 큰 집합, x 단일 개체로 이루어진 집합으로 나누어진다.


![chap07-03](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/b7cb7308-bf54-400f-9f00-2271144fd56c)
* PARTITION 루프를 한번 반복할 때 생기는 두 가지 경우
* (a) : A[j] > x면 단순히 j를 증가시키는 것만으로 루프 불변성이 유지된다.
* (b) : A[j] <= x이면 인덱스 i를 증가시키고 A[i]와 A[j]를 교환한 다음 j를 증가시킨다. 이 경우에도 루프 불변성이 유지된다.

## 7.2 퀵 정렬의 성능
### 분할을 가장 나쁘게 하는 경우
퀵 정렬에서 최악의 경우
* 원래의 문제를 n - 1개 짜리와 0 개 짜리 부분 문제로 나누는 때

재귀할 때마다 이런 불균등 분할이 발생한다고 가정
* 분할 과정 : O(n)
* 크기가 0인 배열에 대한 재귀 호출은 결과가 즉시 리턴 T(0) = O(1)

따라서 수행 시간에 대한 재귀 관계식은
* T(n) = T(n - 1) + T(n) + O(n) = T(n - 1) + O(n)

직관적으로 각 재귀 호출 단계에서 발생하는 비용을 모두 더하면
* O(n^2)인 등차 급수를 얻는다.
* O(n^2)이라는 수행 시간은 입력 배열이 거의 완전히 정렬되어 있을 때 일어난다.
* 삽입 정렬을 이용하면 이 경우 O(n) 시간에 정렬이 가능하다.

### 분할을 가장 잘하는 경우
가장 고른 분할은 PARTITION이 생성하는 부분 문제의 크기가 모두 n / 2인 경우

상한과 하한 함수, -1과 같은 상수항을 무시한다면 수행시간에 대한 재귀 관계식은
* T(n) = 2T(n / 2) + O(n)
* T(n) = O(n lg n)

### 균등 분할
항상 9 대 1로 분할하는 경우
* T(n) <= T(9n / 10) + T(n / 10) + cn
* 깊이가 log(밑10)n = O(lg n)에 이를 때까지는 트리의 각 레벨에서 비용은 cn이고
* 그 다음부터는 cn보다 작거나 같다.
* 재귀는 log(10/9)n = O(lg n)에서 끝난다.
* 즉, 퀵 정렬의 비용은 O(n lg n)

![chap07-04](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/da5a0920-429a-4e70-9684-847de4c99314)
* 점근적으로 결국 99대1로 분할되더라도 O(n lg n) 수행시간이 나온다.
