# 1 알고리즘의 역할
## 1.1 알고리즘
알고리즘의 정의
* 값 혹은 값의 집합을 입력으로 받아 또 다른 값 혹은 값의 집합을 출력하는 잘 정의된 계산 절차
* 입력 -> 출력으로 변환하는 계산 과정
* 계산 문제를 풀기위한 도구로도 볼 수 있다.


알고리즘이 모든 입력 사례에 대해 항상 올바른 출력을 내고 종료 -> 타당하다(correct)
* 그 타당한 알고리즘이 주어진 계산 문제를 푼다(solve)

타당하지 않은 알고리즘
* 일부 입력 사례에서 종료되지 않거나 잘못된 답을 도출

알고리즘은 사람의 언어로 간단히 작성할 수 있다.
* 유일한 요구사항은 이런 명세가 필요한 계산 절차를 자세히 설명해야 한다는 것

### 어떤 문제를 알고리즘으로 푸는가

몇 가지 예
* 인간 게놈 프로젝트
* 인터넷 사이트 데이터 관리 - 검색 효율성 등
* 전자 상거래 - 수치 알고리즘과 정수론 기반
* 제조업과 기타 영리기업에서 희소 자원 효율적 운용 - 선형 계획법

위 예를 다루는 것은 책의 범주를 벗어남

이런 문제를 해결하는 기반 지식
* 인접 교차로
* 부분 수열 구하기
* 위상 정렬

등등,,,

흥미로운 알고리즘 문제에서 발견되는 두 가지 특징
1. 많은 후보해 중 문제의 해 혹은 "최상의" 해를 찾는 일은 대단히 도전적인 일
2. 실용적인 응용 예가 존재 - 최단 경로 문제 등


### 자료구조
자료구조란?
* 자료를 편리하게 접근하고 변경하기 위해 자료를 저장하거나 조직하는 방법
* 각 자료구조의 장점과 한계를 잘 아는 것이 중요하다.
  
### 병렬성
클록 속도의 한계로 최신 컴퓨터는 여러 개의 코어를 가지도록 설계

즉, 멀티 코어 컴퓨터는 한개의 칩 위에 컴퓨터가 여러 대 놓인 것으로 생각할 수 있다.
* 일종의 병렬 컴퓨터(parallel computer)
* 멀티 코어 컴퓨터로부터 최고의 성능을 얻으려면 병렬성을 염두에 두어야 한다.

## 1.2 기술로서의 알고리즘
컴퓨터가 무한히 빠르고 메모리 비용이 들지 않는다면 알고리즘을 학습할 이유가 있을까?
* 개발한 알고리즘을 증명하고자 하는 경우라면 -> "그렇다."

그러나 컴퓨터가 상당히 빠를 수는 있지만 무한히 빠를 수는 없고,\
메모리가 매우 저렴할 수는 있지만 전혀 들지 않을 수는 없다.
* 결국 계산 시간과 메모리는 한정된 자원
* 이를 효율적으로 사용해야하고, 시간 공간 모두 효율적인 알고리즘이 필요하다.

### 효율성
알고리즘의 차이는 하드웨어나 소프트웨어로 인한 차이보다 더 심할 수 있다.

두 가지의 정렬 알고리즘
* 삽입 정렬 : c1n^2
* 병합 정렬 : c2nlgn

여기서 삽입 정렬은 c1 < c2 로 병합 정렬보다 더 작은 상수를 가진다.


컴퓨터 A는 초당 100억 개 명령어 실행, 컴퓨터 B는 1000배 더 빠르다고 하자.
* 컴퓨터 A : 삽입 정렬 실행 : 2n^2
* 컴퓨터 B : 병합 정렬 실행 : 50nlgn

이라고 하면 1000만 개의 숫자를 정렬할 때 어떤 컴퓨터가 더 빠르게 실행할 수 있을까?

컴퓨터 A

![chap01-01](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/328b5ca8-5e2f-4a70-a116-83eac6046d2d)

컴퓨터 B

![chap01-02](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/f2fb9323-7cea-4f05-908d-8c846e769131)

컴퓨터 B가 훨씬 좋지 않은 컴퓨터임에도 17배 빠르다.
* 일반적으로 문제의 크기가 커질수록 병합 정렬의 상대적인 장점도 커진다.

### 알고리즘과 다른 기술들
알고리즘도 하드웨어처럼 하나의 기술이다.

최근 컴퓨터 분야에서 알고리즘은 정말로 중요할까?
* 당연히 그렇다.
* 문제의 크기가 아주 커지면 그 차이가 두드러진다.