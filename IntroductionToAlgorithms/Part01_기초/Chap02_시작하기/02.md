# 2 시작하기
이 장에서는 책 전반에 걸쳐 사용하는 체계를 알아본다.
* 의사코드 등

삽입 정렬과 병합 정렬을 알아본다.

## 2.1 삽입 정렬

정렬 문제를 풀기 위한 문제를 다음과 같이 정의한다.

입력: n개의 수들의 수열 \<a1, a2, ... , an>\
출력: a'1 <= a'2 <= ... <= a'n을 만족하는 입력 수열의 순열(재배치) \<a'1, a'2, ... , a'n>

정렬 대상 숫자를 키라고 한다.
* 수열은 원소가 n개인 배열을 입력으로 준다.

### 의사코드
알고리즘을 간결하게 표현하기 위해 어떤 방법을 사용해도 된다.
* 영어 혹은 한글이 간결한 표현일 수 있다.

### 삽입 정렬 알고리즘
가장 적절한 수를 찾아서 이미 정렬된 수열에 삽입
* 입력된 원소를 적절한 위치로 정렬한다.

삽입 정렬의 진행 과정

![chap02-01](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/a8e49d32-adbb-4e2e-bdac-9cb8e064e881)

삽입 정렬 의사 코드 INSERTION-SORT(A)
~~~C
1:  for j = 2 to A.length
2:      key = A[j]
3:      // A[j]를 정렬된 배열 A[1..j-1]에 삽입한다.
4:      i = j - 1
5:      while i > 0 AND A[i] > key
6:          A[i + 1] = A[i]
7:          i = i - 1
8:      A[i + 1] = key
~~~


### 루프 불변성과 삽입 정렬의 타당성
루프 불변성
* 삽입 정렬에서
  1. for 루프에서 인덱스 j의 반복이 시작될 때
  2. 부분 배열 A[1..j-1]은 이미 정렬된 부분
  3. 부분 배열 A[j+1..n]은 아직 정렬되지 않은 부분
  4. 즉, A[1..j-1]은 그냥 j-1번째까지의 값이지만 이제는 정렬되어 저장된 것
* 이런 특성이 바로 루프 불변성이다.

1-8행의 부분 배열 A[1..j-1]은 원래 A[1..j-1] 원소지만 for 루프가 반복을 시작할 때마다 정렬된 순서로 구성된다.


루프 불변성은 알고리즘이 타당한 이유를 쉽게 이해할 수 있도록 하기 위해 사용된다.


### 루프 불변성을 보이기 위한 세가지 특성
**초기조건**: 루프가 첫 번째 반복을 시작하기 전 루프 불변성이 참이어야 한다.\
**유지조건**: 루프 반복 시작 전 루프 불변성이 참 -> 다음 반복 이전에도 계속 참\
**종료조건**: 루프가 종료될 때 -> 불변식이 알고리즘의 타당성을 보이는데 도움이 될 유용한 특성을 가져야 한다.

초기조건과 유지조건을 만족하면 루프가 반복을 시작할 때 루프 불변성은 항상 참이다.
* 루프 불변성이 유지됨을 보이기 위해 다른 특성을 사용해도 된다.
* 이는 수학의 귀납법과 유사함

종료조건이 가장 중요하다.
* 결국 루프 불변성을 보이는 목적이 결국 알고리즘의 타당성을 보이는 것이기 때문
* 보통 루프의 종료조건이 완료될 때까지 루프 불변성을 이용
* 루프가 종료될 때 귀납적 과정도 끝난다.

### 삽입 정렬 알고리즘에서 루프 불변성
**초기조건**
* 먼저 루프의 첫 반복 시작 전, j = 2일 때 루프 불변성이 성립하는지를 살펴본다.
* 이때 부분 배열 A[1..j-1]은 A[1] 한 개, 이 부분은 정렬되어 있으므로 루프 불변성 성립

**유지조건**
* A[j]의 올바른 위치를 찾을 때까지
* A[j-1], A[j-2], ...를 오른쪽으로 한 자리 씩 이동시키는 작업을 한다.
* 적절한 위치를 찾았다면 A[j]를 적절한 위치에 삽입한다.
* A[1..j]는 정렬한 상태를 가지게 된다.
* 이를 통해 다음 바복에서 루프 불변성이 유지된다.

**종료조건**
* j = n + 1일 때 루프는 종료된다.
* 루프 불변성의 기술에서 j에 n+1을 넣어보면 A[1..n]으로 절렬된 순서로 저장됨을 알 수 있다.
* 결국 A[1..n]이 전체 배열이므로 배열 전체가 정렬되었다. - 이는 알고리즘의 타당함을 의미한다.

### 의사코드의 규칙

이 책의 의사코드는 다음의 관행을 따른다.
* 들여쓰기는 블록 구조를 나타낸다.
* while, for, repeat-until 같은 반복문과 if, then, else 같은 조건문은 다른 언어와 비슷하게 해석된다.
* 기호 "//"는 주석을 나타낸다.
* i = j = e 다중 할당식은 두 변수 i, j에 e값을 할당하는 것을 말한다.
* 전역 변수를 사용할 경우에는 이를 분명히 명시한다. 
  * 별 다른 표기가 없다면 지역 변수다.
* 배열의 원소는 []를 통해 접근한다.
* 복합 데이터는 전형적으로 객체 형태로 만들어지며 객체는 필드로 구성된다. 
  * .으로 다른 요소에 접근할 수 있다.
* 프로시저의 매개 변수는 값에 의해 전달된다. (call by value)
  * 피호출 프로시저는 매개변수에 대해 복사본을 가진다.
  * return 문은 호출 즉시 호출 프로시저로 돌아간다.
  * return 문으로 여러 값을 리턴할 수 있다.
* "and"와 "or" 같은 논리 연산자는 조기 차단할 수 있다.
  * x and y 문에서 x를 먼저 평가하고 x 가 false라면 y는 계산조차 하지 않는다.
* error는 조건이 잘못되어 오류가 발생함을 의미한다.
  * 오류에 대한 처리는 호출 프로시저에서 이루어지므로 프로시저에서는 오류 처리를 명시하지 않는다.

## 2.2 알고리즘의 분석
알고리즘의 분석이란?
* 알고리즘을 실행하는 데 필요한 자원을 예측하는 것
* 대부분의 경우 - 계산 시간

구현 기술의 모델
* 이 책에서는 단일 프로세서와 랜덤 접근 기계(RAM, random-access model)

RAM 모델
* 명령어는 동시에 수행되지 않고 차례로 하나씩 실행된다.
* 산술 연산, 데이터 이동 연산, 제어 연산 등을 지원한다. - 상수 시간이 걸린다.
* 데이터형은 정수(integer)와 부동소수(floating point)다.
* 현대의 컴퓨터 메모리 계층을 고려하지 않는다. - 캐시나 가상 메모리는 없다.

RAM 모델에 비해 현대의 컴퓨터는 분석이 매우 어렵다.
* RAM 모델에서의 분석만으로도 실제 기계의 성능을 대체로 잘 예측할 수 있다.

### 삽입 정렬의 분석
INSERTION-SORT의 수행시간은 입력에 의해 결정된다.
* "수행시간"과 "입력 크기"를 주의 깊게 정의할 필요가 있다.

**입력 크기**
* 주어진 문제에 따라 다르다. - 책에서는 각 문제마다 정의
* 정렬이나 이산 푸리에 변환 계산 등 입력이 많은 문제 -> 입력 항목의 개수
* 입력을 일반적인 이진수로 표현하는 문제 -> 총 비트 수
* 그래프의 경우 -> 노드의 개수와 간선의 개수

**수행시간**
* 기본 연산 개수 또는 실행된 "단계"의 횟수
* 가능한 실행 단계의 개념으로 정의하는 것이 편하다.

먼저 INSERTION-SORT 프로시저를 각 명령문의 실행에 따른 시간"비용"과 실행 횟수를 고려해 살펴보자.

![chap02-02](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/765451d7-d8f5-488d-b3eb-21b6aad6cb08)

INSERTION-SORT의 수행시간 T(n)을 구하기 위해 비용과 횟수의 합을 구하면

![chap02-03](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/c3168cf7-2b3a-44e7-a76a-f5b802c5e322)

입력이 크기가 이미 정해진 경우 어떤 입력이냐에 따라 알고리즘의 수행 시간은 변한다.
* 최선의 상황은 이미 배열이 정렬된 상황
* j = 2, 3, ..., n의 각 경우에 대해 i가 j-1로 초기화될 때 5행에서 A[i] <= key가 된다.
* 따라서 j = 2, 3, ..., n에 대해 tj = 1이 되며 수행 시간은

![chap02-04](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/529fc225-8d9d-4101-a82c-e2c8550ac25b)


즉, 이 수행시간을 ci에 의존하는 상수 a, b에 대한 an + b로 표현할 수 있다.
* 따라서, n에 대한 선형 함수가 된다.

배열이 역순으로 정렬되어 있는 경우가 최악의 상황이다.
* 이 경우 각 A[j]를 A[1..j-1]과 전부 비교해야 하므로 j = 2, 3, ..., n에 대해 tj = j가 된다.

즉, 최악의 경우 INSERTION-SORT의 수행시간은 다음이 된다.

![chap02-05](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/61ce877f-c867-457e-8181-089337bc980e)

결국 ci에 의존하는 상수 a, b, c에 대한 an² + bn + c로 표현할 수 있다.
* 즉, 수행시간은 n에 대한 이차식이다.

삽입 정렬의 경우 일반적으로 입력이 주어지면 이에 대한 수행시간은 일정하다.
* 그러나 "랜덤화된" 알고리즘은 고정된 입력에서도 수행시간은 달라질 수 있다. - 뒤에 설명

### 최악의 경우와 평균적인 경우의 분석
앞으로는 **최악의 경우 수행시간**만 관심을 가진다.
1. 최악의 경우보다 나쁜 경우는 존재하지 않는다.
2. 어떤 알고리즘은 최악의 경우가 상당히 빈번할 수 있다.
3. "평균적인 경우"가 최악의 경우만큼 거의 좋지 못한 상황일 때가 종종 있다.

어떤 경우에는 **평균 수행시간**이 중요하다.
* 5장에서 알아볼 **확률적 분석** 기법 : 이를 통해 수행시간의 평균값을 구할 수 있다.
* 문제에 대해 무엇이 "평균적인" 입력인지 불확실할 수 있다.
* 이때는 랜덤화된 알고리즘을 사용해 평균 수행시간을 구하기도 한다. - 5장과 이후의 장에서 알아본다.

### 증가 차수
앞서 분석을 편하게 하기 위해 몇 가지 단순한 개념을 이용했다.
* 각 명령문의 실제 비용을 무시하고 상수 ci로 표현
  * ci도 복잡했다. 상수 a, b, c로도 충분했다.

좀 더 단순하게 추상화
* 수행시간의 **증가 비율** 또는 **증가 차수**를 이용할 수 있다.
* 충분히 큰 n에 대해 차수가 낮은 항은 상대적으로 덜 중요하다.
* 따라서 차수가 가장 높은 항만 고려한다.
* 상수 계수 또한 무시한다. - 증가 비율에 비해 덜 중요
* 빅-O 표기법

## 2.3 알고리즘의 설계

이번 장에서는 분할 정복 방법론을 살펴본다.

### 2.3.1 분할 정복 접근법

재귀적 구조
* 주어진 문제를 풀기 위해 자신을 재귀적으로 여러 번 호출하여 부분 문제를 다룬다.
* 이런 알고리즘은 분할정복 접근법을 따른다.

분할정복의 세 가지 단계
* 분할: 현재의 문제를 다수의 부분 문제로 분할한다.
* 정복: 부분 문제를 재귀적으로 푼다. 부분 문제가 충분히 작으면 직접적인 방법으로 푼다.
* 결합: 부분 문제의 해를 결합하여 원래 문제의 해가 되도록 한다.

병합 정렬의 설명
* 분할: 정렬할 n개 원소의 배열을 n/2개 씩 부분 수열 두 개로 분할한다.
* 정복: 병합 정렬을 이용해 두 부분 배열을 재귀적으로 정렬한다.
* 결합: 정렬된 두 개의 부분 배열을 병합해 정렬된 배열 하나로 만든다.

병합 정렬 알고리즘의 핵심은 "결합"
* 병합을 위해 보조 프로시저 MERGE(A, p, q, r)이 필요
* A는 배열 p, q, r은 인덱스 p <= q < r을 만족
* 프로시저 MERGE는 두 부분 배열이 정렬되어 있다고 가정하고 이를 병합

MERGE 프로시저는 O(n) 실행시간
* n = r - p + 1


MERGE(A,p,q,r) 의사코드
* INFINTE : 경계값
~~~C++
1:  n1 = q - p + 1
2:  n2 = r - q
3:  // 배열 L[1..n1+1]과 R[1..n2+2]을 생성한다.
4:  for i = 1 to n1
5:    L[i] = A[p + i - 1]
6:  for j = 1 to n2
7:    R[j] = A[q + i]
8:  L[n1 + 1] = INFINTE
9:  R[n2 + 1] = INFINTE
10: i = 1
11: j = 1
12: for k = p to r
13:   if L[i] <= R[j]
14:     A[k] = L[i]
15:     i = i + 1
16:   else A[k] = R[j]
17:     j = j + 1
~~~
* 1~9 행 : L(left), R(Right) 배열에 값을 채우고 마지막 경계값을 지정한다.
* 12~17 행 : 더 작은 값을 먼저 원본 배열에 하나씩 복사한다.

MERGE 진행 과정

![chap02-06](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/69baeeb8-3cdc-4a4d-abcf-d1b55f96b261)

![chap02-07](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/bb60e0cc-42fc-4aad-abf6-6150becff58d)

12-17 행의 루프 불변성
* 초기조건: 루프의 첫 번쨰 반복이 시작되기 직전 k = p이므로 부분 배열 A[p..k-1]은 비어있다. 이 빈 배열은 k - p = 0 개의 원소를 가지고 있고, i = j = 1이므로 L[i]와 R[j]는 각각 A로 복사되지 않은 원소 중 가장 작은 원소를 가지고 있다.
* 유지조건: L[i] <= R[j]의 경우, L[i]는 아직 A로 복사되지 않은 가장 작은 원소. A[p..k-1]은 k - p 개의 가장 작은 원소를 가지고 있으므로 14행에서 L[i]를 A[k]로 복사하면 부분 배열 A[p..k]는 k - p + 1 개의 가장 작은 원소를 정렬된 순서로 저장하게 된다. k와 i를 증가시키는 것은 다음 반복에서의 루프 불변성을 확립한다. 반대의 경우도 마찬가지
* 종료조건: 종료될 때는 k = r + 1이다. 루프 불변성에 의해 부분 배열 A[p..k-1], 즉 A[p..r]은 L[1..n1+1]과 R[1..n2+1]에서 가장 작은 k - p = r - p + 1개의 원소를 정렬된 순서로 저장한다. 배열 L과 R은 모두 합쳐 n1 + n2 + 2 = r - p + 3개의 원소를 가지고 있다. 가장 큰 두개의 원소를 제외하고 모두 A로 복사되는데, 이는 경계값이다.

MERGE 프로시저는 n = r - p + 1일 때 O(n) 시간에 수행된다.
* 1~3 행과 8~11 행에서 상수시간이 걸리고
* 4~7 행의 for 루프에서 O(n1 + n2) = O(n) 시간이 걸리며
* 12~17 행의 for 루프에서 n번 반복이 발생하고 
* 이들 각 루프에 상수 시간이 걸린다는 사실에서 증명 가능

이제 MERGE 프로시저를 정렬 알고리즘의 서브 루틴으로 이용
* MERGE-SORT(A, p, r)은 부분 배열 A[p..r]을 정렬하는 프로시저
* p >= r 이면 이미 정렬된 상태라 볼 수 있다.
* 그렇지 않으면 A[p..r]을 두 개의 부분 배열로 분할한다. A[p..q]와 A[q+1..r]

MERGE-SORT 동작 과정 - n이 2의 거듭 제곱일 때

![chap02-08](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/eb466989-888b-4b26-8a71-321f97037dca)

MERGE-SORT(A, p, r) 의사 코드
~~~C++
1:  if p < r
2:    q = (p + r) / 2
3:    MERGE-SORT(A, p, q)
4:    MERGE-SORT(A, q + 1, r)
5:    MERGE(A, p, q, r)
~~~
* 전체 수열 A = <A[1], A[2], ..., A[n]>을 정렬하려면 MERGE-SORT(A, 1, A.length)를 호출한다.
* 여기서 A.length = n


### 2.3.2 분할 정복 알고리즘의 분석
점화식 혹은 재귀 방정식으로 재귀 호출의 수행시간을 설명할 수 있다.
* 이는 입력 크기가 n인 문제에 대한 전체 수행시간을 더 작은 크기의 입력에 대한 수행시간으로 나타내는 것

분할 정복 알고리즘의 수행시간에 관한 점화식은 세 단계로 만들어진다.
* T(n)을 입력 크기가 n인 문제에 대한 수행시간이라 하자.
* 문제의 크기가 작아 상수 c에 대해 n <= c라 할 때 이는 상수 시간으로 O(1)로 쓴다.
* 원래 문제의 1 / b인 a개의 부분 문제로 분할된다 가정(병합정렬은 b = a = 2)
* 이때 크기가 n / b인 부분 문제에서 T(n / b) 시간이 걸렸다면 a개 해결하는 데 aT(n/b)의 시간이 걸린다.
* 문제를 분할하는데 D(n), 결합하는데 C(n)이 걸린다면

다음 점화식을 얻을 수 있다.

![chap02-09](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/66c1b7cd-f358-4c4d-9688-4bde5abd7321)

### 병합 정렬의 분석
문제의 크기를 2의 거듭제곱으로 가정하면 분석을 단순화할 수 있다.
* 각 단계에서 정확히 n / 2인 두 부분 배열로 나눌 수 있기 때문
* 4장에서 이런 가정이 점화식의 풀이에 증가 차수가 영향을 미치지 않는다는 것을 확인

n개의 수를 정렬하는 병합 정렬에서 최악의 경우 수행시간 T(n)에 관한 점화식을 추론
* 원소의 개수가 한 개라면 병합 정렬 - 상수시간

원소가 n > 1 개일 때 수행시간
* 분할: 분할 단계는 부분 배열의 중간 위치 계산 - 상수시간 D(n) = O(1)
* 정복: 두 개의 부분 문제를 재귀적으로 추는데, 각 부분 문제는 크기가 n / 2 - 2T(n/2)
* 결합: n개의 원소에 대해 MERGE 프로시저는 O(n) 시간 - C(n) = O(n)

병합 정렬에서 C(n) = O(n), D(n) = O(1)
* 이 두 함수의 합은 n의 선형 함수 O(n)이다.

정복 단계에서 2T(n/2)을 더하므로 최악의 경우 T(n)에 대한 점화식은

![chap02-10](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/45842e30-f440-4bfa-bab9-78f95d96c660)