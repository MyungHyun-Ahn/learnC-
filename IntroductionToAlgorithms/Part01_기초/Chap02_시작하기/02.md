# 2 시작하기
이 장에서는 책 전반에 걸쳐 사용하는 체계를 알아본다.
* 의사코드 등

삽입 정렬과 병합 정렬을 알아본다.

## 2.1 삽입 정렬

정렬 문제를 풀기 위한 문제를 다음과 같이 정의한다.

입력: n개의 수들의 수열 \<a1, a2, ... , an>\
출력: a'1 <= a'2 <= ... <= a'n을 만족하는 입력 수열의 순열(재배치) \<a'1, a'2, ... , a'n>

정렬 대상 숫자를 키라고 한다.
* 수열은 원소가 n개인 배열을 입력으로 준다.

### 의사코드
알고리즘을 간결하게 표현하기 위해 어떤 방법을 사용해도 된다.
* 영어 혹은 한글이 간결한 표현일 수 있다.

### 삽입 정렬 알고리즘
가장 적절한 수를 찾아서 이미 정렬된 수열에 삽입
* 입력된 원소를 적절한 위치로 정렬한다.

삽입 정렬의 진행 과정

![chap02-01](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/a8e49d32-adbb-4e2e-bdac-9cb8e064e881)

삽입 정렬 의사 코드 INSERTION-SORT(A)
~~~C
1:  for j = 2 to A.length
2:      key = A[j]
3:      // A[j]를 정렬된 배열 A[1..j-1]에 삽입한다.
4:      i = j - 1
5:      while i > 0 AND A[i] > key
6:          A[i + 1] = A[i]
7:          i = i - 1
8:      A[i + 1] = key
~~~


### 루프 불변성과 삽입 정렬의 타당성
루프 불변성
* 삽입 정렬에서
  1. for 루프에서 인덱스 j의 반복이 시작될 때
  2. 부분 배열 A[1..j-1]은 이미 정렬된 부분
  3. 부분 배열 A[j+1..n]은 아직 정렬되지 않은 부분
  4. 즉, A[1..j-1]은 그냥 j-1번째까지의 값이지만 이제는 정렬되어 저장된 것
* 이런 특성이 바로 루프 불변성이다.

1-8행의 부분 배열 A[1..j-1]은 원래 A[1..j-1] 원소지만 for 루프가 반복을 시작할 때마다 정렬된 순서로 구성된다.


루프 불변성은 알고리즘이 타당한 이유를 쉽게 이해할 수 있도록 하기 위해 사용된다.


### 루프 불변성을 보이기 위한 세가지 특성
**초기조건**: 루프가 첫 번째 반복을 시작하기 전 루프 불변성이 참이어야 한다.\
**유지조건**: 루프 반복 시작 전 루프 불변성이 참 -> 다음 반복 이전에도 계속 참\
**종료조건**: 루프가 종료될 때 -> 불변식이 알고리즘의 타당성을 보이는데 도움이 될 유용한 특성을 가져야 한다.

초기조건과 유지조건을 만족하면 루프가 반복을 시작할 때 루프 불변성은 항상 참이다.
* 루프 불변성이 유지됨을 보이기 위해 다른 특성을 사용해도 된다.
* 이는 수학의 귀납법과 유사함

종료조건이 가장 중요하다.
* 결국 루프 불변성을 보이는 목적이 결국 알고리즘의 타당성을 보이는 것이기 때문
* 보통 루프의 종료조건이 완료될 때까지 루프 불변성을 이용
* 루프가 종료될 때 귀납적 과정도 끝난다.

### 삽입 정렬 알고리즘에서 루프 불변성
**초기조건**
* 먼저 루프의 첫 반복 시작 전, j = 2일 때 루프 불변성이 성립하는지를 살펴본다.
* 이때 부분 배열 A[1..j-1]은 A[1] 한 개, 이 부분은 정렬되어 있으므로 루프 불변성 성립

**유지조건**
* A[j]의 올바른 위치를 찾을 때까지
* A[j-1], A[j-2], ...를 오른쪽으로 한 자리 씩 이동시키는 작업을 한다.
* 적절한 위치를 찾았다면 A[j]를 적절한 위치에 삽입한다.
* A[1..j]는 정렬한 상태를 가지게 된다.
* 이를 통해 다음 바복에서 루프 불변성이 유지된다.

**종료조건**
* j = n + 1일 때 루프는 종료된다.
* 루프 불변성의 기술에서 j에 n+1을 넣어보면 A[1..n]으로 절렬된 순서로 저장됨을 알 수 있다.
* 결국 A[1..n]이 전체 배열이므로 배열 전체가 정렬되었다. - 이는 알고리즘의 타당함을 의미한다.

### 의사코드의 규칙

이 책의 의사코드는 다음의 관행을 따른다.
* 들여쓰기는 블록 구조를 나타낸다.
* while, for, repeat-until 같은 반복문과 if, then, else 같은 조건문은 다른 언어와 비슷하게 해석된다.
* 기호 "//"는 주석을 나타낸다.
* i = j = e 다중 할당식은 두 변수 i, j에 e값을 할당하는 것을 말한다.
* 전역 변수를 사용할 경우에는 이를 분명히 명시한다. 
  * 별 다른 표기가 없다면 지역 변수다.
* 배열의 원소는 []를 통해 접근한다.
* 복합 데이터는 전형적으로 객체 형태로 만들어지며 객체는 필드로 구성된다. 
  * .으로 다른 요소에 접근할 수 있다.
* 프로시저의 매개 변수는 값에 의해 전달된다. (call by value)
  * 피호출 프로시저는 매개변수에 대해 복사본을 가진다.
  * return 문은 호출 즉시 호출 프로시저로 돌아간다.
  * return 문으로 여러 값을 리턴할 수 있다.
* "and"와 "or" 같은 논리 연산자는 조기 차단할 수 있다.
  * x and y 문에서 x를 먼저 평가하고 x 가 false라면 y는 계산조차 하지 않는다.
* error는 조건이 잘못되어 오류가 발생함을 의미한다.
  * 오류에 대한 처리는 호출 프로시저에서 이루어지므로 프로시저에서는 오류 처리를 명시하지 않는다.

## 2.2 알고리즘의 분석
알고리즘의 분석이란?
* 알고리즘을 실행하는 데 필요한 자원을 예측하는 것
* 대부분의 경우 - 계산 시간

구현 기술의 모델
* 이 책에서는 단일 프로세서와 랜덤 접근 기계(RAM, random-access model)

RAM 모델
* 명령어는 동시에 수행되지 않고 차례로 하나씩 실행된다.
* 산술 연산, 데이터 이동 연산, 제어 연산 등을 지원한다. - 상수 시간이 걸린다.
* 데이터형은 정수(integer)와 부동소수(floating point)다.
* 현대의 컴퓨터 메모리 계층을 고려하지 않는다. - 캐시나 가상 메모리는 없다.

RAM 모델에 비해 현대의 컴퓨터는 분석이 매우 어렵다.
* RAM 모델에서의 분석만으로도 실제 기계의 성능을 대체로 잘 예측할 수 있다.

### 삽입 정렬의 분석
INSERTION-SORT의 수행시간은 입력에 의해 결정된다.
* "수행시간"과 "입력 크기"를 주의 깊게 정의할 필요가 있다.

**입력 크기**
* 주어진 문제에 따라 다르다. - 책에서는 각 문제마다 정의
* 정렬이나 이산 푸리에 변환 계산 등 입력이 많은 문제 -> 입력 항목의 개수
* 입력을 일반적인 이진수로 표현하는 문제 -> 총 비트 수
* 그래프의 경우 -> 노드의 개수와 간선의 개수

**수행시간**
* 기본 연산 개수 또는 실행된 "단계"의 횟수
* 가능한 실행 단계의 개념으로 정의하는 것이 편하다.

먼저 INSERTION-SORT 프로시저를 각 명령문의 실행에 따른 시간"비용"과 실행 횟수를 고려해 살펴보자.

![chap02-02](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/765451d7-d8f5-488d-b3eb-21b6aad6cb08)

INSERTION-SORT의 수행시간 T(n)을 구하기 위해 비용과 횟수의 합을 구하면

![chap02-03](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/c3168cf7-2b3a-44e7-a76a-f5b802c5e322)

입력이 크기가 이미 정해진 경우 어떤 입력이냐에 따라 알고리즘의 수행 시간은 변한다.
* 최선의 상황은 이미 배열이 정렬된 상황
* j = 2, 3, ..., n의 각 경우에 대해 i가 j-1로 초기화될 때 5행에서 A[i] <= key가 된다.
* 따라서 j = 2, 3, ..., n에 대해 tj = 1이 되며 수행 시간은

![chap02-04](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/529fc225-8d9d-4101-a82c-e2c8550ac25b)


즉, 이 수행시간을 ci에 의존하는 상수 a, b에 대한 an + b로 표현할 수 있다.
* 따라서, n에 대한 선형 함수가 된다.

배열이 역순으로 정렬되어 있는 경우가 최악의 상황이다.
* 이 경우 각 A[j]를 A[1..j-1]과 전부 비교해야 하므로 j = 2, 3, ..., n에 대해 tj = j가 된다.

즉, 최악의 경우 INSERTION-SORT의 수행시간은 다음이 된다.

![chap02-05](https://github.com/MyungHyun-Ahn/learnCpp/assets/78206106/61ce877f-c867-457e-8181-089337bc980e)

결국 ci에 의존하는 상수 a, b, c에 대한 an² + bn + c로 표현할 수 있다.
* 즉, 수행시간은 n에 대한 이차식이다.

삽입 정렬의 경우 일반적으로 입력이 주어지면 이에 대한 수행시간은 일정하다.
* 그러나 "랜덤화된" 알고리즘은 고정된 입력에서도 수행시간은 달라질 수 있다. - 뒤에 설명

### 최악의 경우와 평균적인 경우의 분석
앞으로는 **최악의 경우 수행시간**만 관심을 가진다.
1. 최악의 경우보다 나쁜 경우는 존재하지 않는다.
2. 어떤 알고리즘은 최악의 경우가 상당히 빈번할 수 있다.
3. "평균적인 경우"가 최악의 경우만큼 거의 좋지 못한 상황일 때가 종종 있다.

어떤 경우에는 **평균 수행시간**이 중요하다.
* 5장에서 알아볼 **확률적 분석** 기법 : 이를 통해 수행시간의 평균값을 구할 수 있다.
* 문제에 대해 무엇이 "평균적인" 입력인지 불확실할 수 있다.
* 이때는 랜덤화된 알고리즘을 사용해 평균 수행시간을 구하기도 한다. - 5장과 이후의 장에서 알아본다.

### 증가 차수
앞서 분석을 편하게 하기 위해 몇 가지 단순한 개념을 이용했다.
* 각 명령문의 실제 비용을 무시하고 상수 ci로 표현
  * ci도 복잡했다. 상수 a, b, c로도 충분했다.

좀 더 단순하게 추상화
* 수행시간의 **증가 비율** 또는 **증가 차수**를 이용할 수 있다.
* 충분히 큰 n에 대해 차수가 낮은 항은 상대적으로 덜 중요하다.
* 따라서 차수가 가장 높은 항만 고려한다.
* 상수 계수 또한 무시한다. - 증가 비율에 비해 덜 중요
* 빅-O 표기법