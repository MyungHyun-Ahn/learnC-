# Chapter 04 메모리
## 4.1 가상 메모리
가상 메모리의 핵심은 프로세스마다 독립적인 메모리 공간이 부여된다는 것이다.
* x86 기준으로 개별 프로세스는 4GB의 메모리 공간을 부여받는다.
* 타 프로세스가 메모리 공간을 침범할 수 없다.

### 4.1.1 가상 메모리 크기
x86은 32비트 시스템이다. 주소를 가리킬 수 있는 레지스터의 크기가 32비트
* 대략 42억개의 주소 각각의 주소가 1바이트이므로 총 4GB의 메모리를 가질 수 있다.
* 4GB의 메모리 중 2GB는 운영체제가 2GB는 프로세스에게 부여된다.

x64의 경우 레지스터의 크기가 64비트이기 때문에 2의 64승개의 주소를 사용할 수 있다.
* 이론상으로는 1600만TB의 메모리 공간이 부여될 수 있다.
* 윈도우의 경우 8TB의 공간만 부여한다.
* 여기서도 운영체제와 프로세스가 4TB 씩 나눠 사용한다.

### 4.1.2 가상 메모리 주소
프로세스가 실제로 사용가능한 메모리의 크기는 1024(물리 메모리)인데 어떻게 더 큰 메모리를 사용할 수 있을까?
* 4096개의 가상 메모리 주소를 부여한다.
* 이것을 어떻게 사용할까?
* 페이징 혹은 스왑 파일

메모리는 일정한 크기 단위로 할당된다.
* 일반적으로 4KB 단위로 할당하고
* 가상 메모리에서는 이것을 페이지(Page)라고 부르고
* 물리 메모리에서는 페이지 프레임(Page Frame)이라고 부른다.

각 프로세스는 페이지 테이블(Page Frame)을 가지고 있다.
* 페이지 테이블에는 가상 메모리의 각 페이지가 현재 물리 메모리의 어떤 프레임에 연결되는지가 테이블 구조로 기록된다.
* 따라서 프로세스가 Page02에 해당하는 메모리에 접근하고 싶다면 페이지 테이블에서 Frame07을 찾은 후 물리 메모리에 접근할 수 있다.

dll의 물리 메모리 프레임은 각 프로세스가 동시에 공유할 수 있다.


### 4.1.3 가상 메모리 구조
실제로 C++ 프로그래밍에서 중요한 것은 프로세스는 오직 가상 메모리만을 바라본다는 것이다.


실제 프로세스가 사용하는 가상 메모리의 프로세스 영역
1. Code(Text) : 코드(함수), 정수 상수
2. Data : 초기화된 전역, 정적 변수
3. BSS : 초기화되지 않은 전역, 정적 변수
4. rodata : 문자열 리터럴
5. Heap : 동적 할당 
6. Stack : 지역 변수


Code(Text) 영역
* 소스코드 그 자체가 저장(함수나 상수)
* 오직 읽기만 가능하다.


데이터와 BSS 영역
* 전역 변수와 전역 배열이 저장
* static도 사실은 전역 변수이다. 접근 속성이 다를 뿐
* 엄밀히 말해서 배열은 변수가 아닌 상수 포인터이다.

데이터와 BSS 영역을 분리한 이유
* 왜 초기화를 기준으로 영역을 분리했을까?
* 완전히 일치하지는 않지만 실행 파일의 내용은 가상 메모리에 비슷한 구조로 올라가게 된다.
* 가상 메모리의 프로세스 영역이 Code, Data, BSS 영역으로 나누어져 있듯이 실행 파일의 구조도 비슷하게 여러 영역으로 분할되어 있다.
* 즉, 각 영역에 대응되는 영역이 있다는 것이다.
* 실제로 Code나 Data 영역은 가상 메모리로 비슷하게 올라간다.
* 그러나 BSS 영역은 그렇지 않다.
  * 초기화 되지 않은 것은 빈 공책이나 마찬가지다. 빈 공책을 보관할 필요가 있을까?

즉, 초기화 여부는 객체 자체의 내용을 저장하느냐, 빈 객체가 있다는 사실을 저장하느냐의 차이라고 할 수 있다.
* 실행 파일의 데이터 영역에는 실제 초기화된 값이 들어있지만
* BSS 영역에는 어떤 객체들이 필요한지 저장되어 있다.


Code 영역과 Data 영역은 프로세스가 시작되면 OS가 그대로 가상 메모리에 복사한다.

BSS 영역에 대해서는 만약 배열 객체의 크기가 32MB라면
* 32MB의 메모리를 확보하고 해당 영역을 0으로 채워 넣는다.


힙과 스택
* 많은 웹의 자료나, 책들은 힙과 스택이 서로 반대 방향으로 자라나고 있는 모습을 보이지만
* 이건 싱글 스레드의 기준이다.
* 멀티 스레드 환경에서는 메모리가 뒤섞여있는 채로 존재할 수 있다.

스택은 스레드당 하나씩 생성된다.
* 기본적으로 스레드당 1MB~4MB 정도를 스레드 스택으로 할당
* 스레드가 생성되는 순간 운영체제는 가상 메모리의 남은 영역 중 적당한 곳을 골라서 할당

힙은 동적 메모리가 저장되는 곳이다.
* 힙은 하나의 커다란 메모리 영역이며, 프로세스에 하나 이상 존재할 수 있다.
* C/C++의 경우 CRT Heap이 프로그램 시작시 기본 생성된다.
* CRT는 자신의 힙을 사용해서 malloc new를 처리한다.

## 4.2 메모리 할당과 해제
### 4.2.1 메모리 할당의 근원
프로세스가 가상 메모리를 할당 받기 위해서는 해당 운영체제에게 메모리 요청을 해야한다.
* 또한 페이지 단위로만 할당 받을 수 있다.

윈도우의 경우 VirtualAlloc API, 리눅스에서는 brk나 mmap이라는 시스템 콜을 제공한다.
* 결국 C/C++의 CRT가 제공하는 malloc이나 new의 근원은 운영체제의 메모리 할당 API나 시스템 콜이다.

malloc, new가 그대로 시스템 콜이나 API를 바로 호출하는 것은 아니다.
* 힙 관리자에 의해 처리된다.
* 힙 관리자는 프로세스 시작시 운영체제를 통해 가상 메모리 덩어리를 할당 받는다.
* malloc, new 호출시 적절히 분할하여 돌려준다.
* 물론 페이지 크기를 넘어서는 메모리를 요청하면 힙 관리자는 직접 API와 시스템 콜을 호출한다.

### 4.2.2 malloc & free
void *malloc(size_t size);

void free(void *memblock);


힙 영역은 할당과 미할당 영역으로 구분될 수 있다.
* malloc 호출시 미할당 영역에서 요청된 크기만큼을 반환하면서 반환된 영역은 할당 영역으로 변경된다.
* malloc 요청이 많아질 경우 할당 영역은 늘어나고, 미할당 영역은 줄어들 것이다.
* 미할당 영역이 존재하지 않을 때 가상 메모리를 할당하여 힙 자체를 늘린다.


free는 할당된 메모리를 해제하는 함수이다.
* free는 해제할 메모리 크기를 인자로 받지 않는다.
* 힙관리자가 malloc으로 할당된 내역을 저장하고 있기 때문이다.


### 4.2.3 new & delete
new는 내부적으로 malloc을 호출한다.

delete 역시 내부적으로 free를 호출한다.

결국 추가적인 처리를 하기 위해 new와 delete를 사용해야 하고
* malloc과 free가 대신할 수 없다.
* 추가적인 처리는 바보 생성자와 소멸자의 호출이다.

결국 핵심은 동적 생성 클래스 객체를 위해 생성자와 소멸자의 호출이다.
* 그런데 실제로 기본 타입도 사용할 수 있다.
* 범용적으로 사용하기 위해서


### 4.2.4 new [] & delete []
new의 경우 [] 연산자를 사용하여 쉽게 배열 타입 객체를 할당 받을 수 있다.
* [] 안에 단순히 배열 요소의 개수만 써주면 되기 때문에 간편하다.

그러나 숨겨진 부분은 굉장히 복잡하다.
* 배열의 경우는 malloc과 동일하게 동작한다.

Class의 경우 만약 4바이트 int 타입 멤버를 1개 가지고 있다고 하자.

~~~
class CTest
{
public:
    int m_Value;
}

int main()
{
    CTest *cArr = new CTest[2];
    delete[] cArr;
}
~~~

위와 같이 4바이트 짜리 객체 2개를 생성하는 경우를 보자.
* 4바이트 짜리 객체 2개를 생성하므로 총 크기는 8바이트인 것 같지만
* 실제로는 size 정보가 추가로 들어간다.
* 필요한 만큼의 소멸자와 생성자를 호출하기 위함이다.

데이터 구조
1. 0 : 02 00 00 00 : 개수 기입
2. 4 : cd cd cd cd : CTest 1
3. 8 : cd cd cd cd : CTest 2

헤더에 기입한 개수를 기준으로 생성자와 소멸자를 호출한다.
* delete[]가 아닌 delete를 호출하면 단 한번만 소멸자를 호출할 것이다.

소멸자가 없는 경우에는 사이즈 헤더가 붙지 않는다.

상속의 경우 자식 클래스에게 명시적인 소멸자가 존재하지 않아도
* 부모 클래스에 소멸자가 존재하면 암시적인 소멸자가 호출되게 한다.

### 4.2.5 Placement new
이미 존재하는 메모리 영역에 생성자만 호출하고 싶은 경우
* Placement new

보통 가변 크기 클래스를 사용하는 경우에 해당한다.
* C++에 도입된 새로운 개념은 아니고, 필자가 붙인 이름

클래스 객체 메모리에 실제 데이터 정보가 모두 담겨있는 구조
* 보통 클래스의 경우 멤버 포인터가 가리키는 영역에 접근하여 정보를 취합해야 하는 오버헤드가 발생한다.
* 가변 클래스의 경우 실제 객체의 크기만큼 메모리를 읽기만하면 된다.
* 가변 크기 클래스의 경우 단순 메모리 복사인 얕은 복사만으로도 객체를 완벽히 복사할 수 있다.

가변 크기 클래스는 나름 장점이 있긴 하지만 상당히 제한적으로 사용될 수 밖에 없다.
* 가장 마지막 멤버에 대해 배열 타입으로 선언해야하기 때문이다.
* 가변 데이터 문자열을 담는 멤버를 두 개 이상은 사용할 수 없다는 것이다.

가변 크기 클래스와 Placement new가 무슨 상관인가?
* 가변 크기 클래스는 결국 malloc을 사용해야 한다.
* 그런데 만약 생성자가 필요하다면 Placement new가 필요하다.

~~~
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <string.h>
#include <windows.h>

class CVSPerson
{
public:
	CVSPerson()
	{
		m_Age = 1;
		m_Name[0] = NULL;
	}

	int m_Age;
	char m_Name[1];
};

int main()
{
	const char *name = "Myung Hyun Ahn";
	void *pData = malloc(sizeof(CVSPerson) + strlen(name));

#pragma push_macro("new")
#undef new
	CVSPerson *pVSPerson = new (pData) CVSPerson;
#pragma pop_macro("new")

	strcat(pVSPerson->m_Name, name);

}
~~~
* 디버그 모드에서 Placement new를 사용하려면 매크로를 붙여줘야 한다.
* new가 DEBUG_NEW로 재정의 되기 때문

### 4.2.6 _msize
할당된 메모리 블록의 포인터를 통해서 블록의 크기를 알고 싶은 경우
* VC++의 CRT 라이브러리의 _msize 함수

size_t _msize(void *memblock);
* MSDN에 따르면 malloc을 비롯한 동적할당을 통하여 힙에 할당된 메모리 블록의 크기를 반환한다.

기본 타입이나 소멸자가 존재하지 않는 클래스는 new[]를 통해 동적할당해도 malloc을 그대로 호출하는 것과 결과가 일치한다.

그런데 소멸자가 존재하는 경우 new[]를 호출하여 반환된 주소가 malloc을 호출하여 반환된 주소와 다르다.
* 이때 _msize를 호출하면 힙 할당 내역에 존재하지 않기 때문에 예외가 발생한다.

즉, _msize 함수는 기본 타입이나 소멸자가 존재하지 않는 클래스에 한해서 사용가능하다.


## 4.3 메모리와 이름
C/C++을 포함한 수많은 프로그래밍 언어가 메모리 블록에 이름을 붙여 사용한다.


### 4.3.1 메모리 블록 구성 요소
메모리 블록이란?
* 메모리 덩어리
* 어떤 크기를 가지면서 연속된 메모리 영역을 메모리 블록이라 한다.

각각의 메모리 블록을 구분하기 위해 필요한 것은 무엇일까?
* 메모리 블록의 주소와 크기

M = [A, S]
* M = Memory Block
* A = Address
* S = Size

메모리 블록을 표현하는 좀 더 개선된 방법

M = [A, S, B]
* B = Bits State
* 실제로 메모리 블록들의 bit on/off 상태


### 4.3.2 이름 연산자
이름을 통해 메모리 블록의 구성 요소들을 구할 수 있는 연산자
1. A = Address(Name)
2. S = Size(Name)
3. B = BitsState(Name)
4. T = Type(Name)
5. V = Value(Name) : Type과 BitsState 연산자의 조합
    * BitsState 연산자를 호출하고 Type을 호출하여 값을 얻어내는 역할

C/C++에서도 이름 연산자와 비슷한 개념의 무언가를 이미 가지고 있다.

* Address에 해당하는 & 주소 연산자.
* Size에 해당하는 것이 바로 sizeof 연산자
* Type에 해당하는 것이 typeid 없다고 봐도 된다.
* BitsState에 해당하는 것은 아예 존재하지도 않는다.
* Value에 해당하는 것은 공식적으로 없지만 이름 자체가 값을 나타낸다.

### 4.3.3 l-value로 사용되는 이름
MSDN에 따르면 모든 C++의 식은 l-value 혹은 r-value이며,
* l-value는 단일 식을 넘어 지속되는 개체를 가리키고
* r-value는 유지되지 않는 임시 값을 가리킨다.

갑자기 l-value가 나온 이유는 바로 메모리 블록의 이름이 l-value이기 때문이다.

결론은 메모리 블록의 이름이 l-value로 사용될 수 있다는 것이다.
* 그러나 배열이나 함수 이름은 l-value로 사용될 수 없다.

### 4.3.4 r-value로 사용되는 이름(값)

~~~
int a = 1;
int b = a; // 1

int *pA = &a;
int *pB = pA; // 2

CTest t1;
t1.m_Value = 1;

CTest t2 = t1; // 3
~~~

* 1, 2, 3을 보면 이름이 값으로 사용되고 있다.
* 여기서 말하는 값은 메모리 블록의 비트 상태가 타입에 의해서 의미가 해석된 것이다.

즉, 메모리 블록의 이름은 r-value로서 사용될 수도 있는 것
* r-value는 바로 메모리 블록의 비트 상태가 나타내는 값으로서의 r-value이다.

### 4.3.5 r-value로 사용되는 이름(주소)
* 이름이 r-value로 사용되긴 하지만 메모리 블록의 비트 상태가 나타내는 값으로서의 r-value가 아니라 다른 의미의 r-value인 경우도 있다.
* 바로 배열 이름과 함수 이름이다.

배열 이름과 함수 이름은 l-value로는 사용되지 않으며 r-value로만 사용된다.
* 간단히 말하면 배열 이름과 함수 이름은 앞에서 설명한 Address 연산자로서 작용한다.

~~~
int main()
{
    int arr1[1] = {1}; // 1
    int arr2[1];

    arr2 = arr1; // 2 Complie Error

    int *pArr = arr1; // 3

    if (arr1 == (void*)&arr1)
    {
        cout << "Equals!" << endl;
    }
}
~~~

1. 1의 단일 식에서 arr1이 배열 이름이다. 식에서 {1}을 대입하고 있다.
2. 즉, arr1이 l-value로 사용되고 있는 것 같다.
3. 그러나 1의 단일 식을 arr1이 l-value로 사용된다고 해석하는 것은 옳지 않다.
4. arr1이라는 블록을 미리 마련하고 arr1 이라는 이름을 통해 1을 대입하는 것이 아닌
5. 1이 채워진 메모리 블록의 이름을 arr1이라고 한 것이다.

2에서는 컴파일 에러가 발생한다.
* 에러 메시지 : arr2가 l-value가 아닙니다.
* 만약 배열의 이름이 l-value였다면 에러가 발생하지 않았을 것이다.

3에서 살펴볼 것은 두 가지이다.
* 첫 번째는 pArr이 배열 이름이 아닌 포인터 객체의 이름이라는 사실이다. 따라서 l-value로 사용될 수 있다.
* 두 번째는 arr1이 r-value로 사용되고 있다는 점이다.
* 이곳의 r-value는 바로 메모리 블록의 주소를 나타내는 상수일 뿐이다.

4를 살펴보자
* &arr1은 메모리 주소의 부분을 가리킨다.
* 결론은 arr1 == &arr1이라는 것이다.

함수의 이름의 경우
* Func == &Func이다.
* 그런데 멤버 함수의 경우 함수 이름이 r-value로 사용될 수 없다.
* & 연산자를 붙이면 아무 문제 없다.
* 컴파일 에러가 발생한다고 해서 함수 이름이 주소가 아니라는 것은 아니다.
* 단지 컴파일러의 강제사항이다.

왜 배열과 함수 이름은 l-value로 사용될 수 없으며, r-value 또한 메모리 블록의 비트 상태를 나타내는 것이 아닌 주소를 나타낼까?
* 배열 요소의 개수는 수백개 이상이될 수 있다. 배열 객체의 개별적인 요소의 값은 의미를 가질 수 있지만.
* 배열 객체의 전체 값이라는 개념은 의미를 가지기에 애매한 점이 있다.
* 따라서 배열 객체에 있어서 메모리 블록의 비트 상태를 해석한 r-value 자체가 무의미 하다고 할 수 있다.
* 그래서 배열의 이름은 메모리 블록의 주소를 나타내도록 한 것이다.

함수의 경우도 비슷하다.
* 값이란 그저 함수 본체일 뿐이다.
* 즉, 함수 본체 자체를 r-value로 사용하는 것은 의미가 없다.
* 따라서 배열과 마찬가지로 함수 이름을 메모리 블록의 주소를 가리키게 한 것이다.