# Chapter 05 포인터와 배열
## 5.1 포인터
메모리의 주소를 가리키는 객체를 포인터라고 부른다.
* 포인터에는 주소뿐만 아니라 타입 정보까지 들어가게 되었다.
* 타입 정보를 통해서 메모리 주소로부터 타입 크기만큼 블록에 값을 읽거나 쓸 수 있게 된 것이다.

### 5.1.1 포인터 타입
TYPE 타입 객체를 가리키기 위해서 TYPE* 타입 포인터를 사용해야 한다.
* 반드시 해당 TYPE의 포인터를 사용해야 하는 건 아니다.

포인터 역시 객체이다.
* int *pA;
* pA는 메모리 주소를 담고 있으므로 포인터다
* pA의 타입은 int*로 표기될 수 있다.
* int*가 결국 int로부터 파생되었으므로 int를 포인터 pA의 원천 타입이라고 부르겠다.
* 즉 원천 타입 int로 부터 int*가 파생되어 포인터 pA가 정의되었다.

포인터의 원천 타입이 포인터가 가리키는 객체의 타입과 일치할 필요는 없다.

~~~
int a = 0;
int *pA = &a;
*pA = 1;
~~~
* pA(4Byte) -> a = 1(4Byte)

pA가 나타내는 메모리 블록의 값은 a가 나타내는 메모리 블록의 주소이다.


객체 타입과 포인터 원천 타입의 불일치
~~~
int a = 0;    // A
char *s = &a; // B-1 Complie Error
char *s = (char *)&a; // B-2

*(s + 0) = 'A';
*(s + 1) = 'B';
*(s + 2) = 'C';
*(s + 3) = '\0';
~~~

* A : int 객체 a를 정의하였다. 메모리 블록 4바이트를 생성, 이름을 a로
* B : char*에 int 객체 a의 주소를 곧바로 대입하면 컴파일러는 일단 거부를 한다.
  * 가능하면 타입을 일치하라는 것이 컴파일러의 주문이다.
  * B-2와 같이 강제 타입 변환을 통해 char* 객체 s는 a를 가리킬 수 있다.
* C는 포인터를 통해 메모리 블록에 값을 쓰는 것을 보여준다.
* D : a블록이 변경되었음을 확인 가능하다.

즉, TYPE *p가 나타내는 의미는 p가 가리키는 주소를 기준으로 sizeof(TYPE) 크기의 비트 상태를 TYPE에 의해 의미를 부여하여 대응시키겠다는 것이다.

### 5.1.2 타입 표기
단일 식 TYPE \*p;에서 p는 포인터이며 포인터 p의 타입은 TYPE*이고, p의 원천 타입은 TYPE이 된다.

TYPE* 형태로 표기할 수 없는 포인터 타입도 존재한다.

배열 포인터 타입 1
~~~C++
typedef int (TARR) [2]; // A
typedef int (*PARR)[2]; // B

int arr[2] = {1, 2}; // 1

int main()
{
    TARR *p1 = &arr; // 2
    PARR p2 = &arr; // 3

    cout << (*p1)[0] << (*p1)[1] << endl;
    cout << (*p2)[0] << (*p2)[1] << endl;

    return 0;
}
~~~
* 1을 보면 배열 객체 arr이 정의되어 있다. arr의 타입은 어떤것이 맞을까?
* int[2]? 아니다 즉, 객체 arr의 타입 자체를 표기할 방법이 없다.
* 타입 정의를 사용하면 된다.
* A를 보자. typedef를 통하여 TARR로 배열 객체의 타입을 나타낼 수 있게 되었다.
* B를 보면 배열 객체의 포인터 타입 또한 나타낼 수 있게 되었다.


typedef를 사용하지 않고 배열의 포인터를 나타내는 방법
~~~c++
int arr[2] = {1, 2}; // 1

template<typename T>
void ArrayPrint(T arg)
{
    cout << (*arg)[0] << (*arg)[1] << endl;
}
~~~

* 배열의 포인터 타입을 인자로 전달될 경우 인자의 타입이 포인터 타입이 되는 것이고
* 그로 인해 인자 arg는 배열을 가리키는 포인터가 된다.
* arg는 포인터이기 때문에 * 연산자를 사용하여 배열 객체처럼 사용하는 요소에 접근할 수 있다.

함수의 포인터 타입
~~~C++
int Func(int arg) // 1
{
    return arg;
}

template<typename T>
void CallFunc(T arg) // 3
{
    cout << arg(1) << endl;
}

int main()
{
    CallFunc<int (*)(int)>(Func); // 2
    return 0;
}
~~~

* 1의 함수 Func의 타입은 시그니처를 이용하여 int(int)로 나타낼 수 있다.
* 만일 Func의 포인터 타입을 표기하기 위하여 단순히 * 연산자를 바로 뒤에 붙인다면 int(int)*가 될 것이다.
* 그러나 이런 표기법은 옳지 않다. 2의 int (*)(int)가 제대로 된 포인터 타입의 표기다.
* CallFunc의 템플릿 인자로 함수의 포인터가 전달될 경우 3의 CallFunc가 구체화되고
* 인자로는 함수 이름이 전달되는데 r-value로 함수 본체의 메모리 주소를 가리키게 된다.
* 즉, arg는 함수를 가리키는 포인터가 된다.

포인터 타입을 만드는 규칙은 다음과 같다.
1. 원천 타입의 객체를 선언한다. 객체의 이름을 * 연산자로 변경한다. 필요한 경우 * 연산자를 괄호로 감싸서 우선 순위를 맞춘다. 마지막 ;를 제거한다.

위의 규칙을 맞추어 int 객체 두 개를 가지는 배열의 포인터 타입을 만들어보자.
1. 배열 객체를 선언한다. int arr[2];
2. 객체 이름을 간접 연산자로 변경한다. int (*)[2];
3. 세미콜론을 제거한다. int (*)[2]


### 5.1.2 포인터와 주소 대응
포인터는 정수형 타입처럼 +, - 연산을 수학적인 방식으로 해석하지 않는다.
* 포인터 방식으로 +, - 연산을 처리한다.
* 포인터 객체에 1을 더한다는 것은 주소의 크기(4) 만큼 더하겠다는 것이다.
* 2라면 2 * 4
* x86 = 4, x64 = 8

### 5.1.3 포인터 연산자
### 5.1.3.1 간접 연산자 - Indirect Operator
*  포인터가 직접 가리키는 것은 메모리의 주소이다.
*  메모리 주소를 통해서 간접적으로 메모리 블록을 나타내기 때문에 간접이라는 뜻을 사용한 것이라고 생각한다.
*  TYPE *p 일 때 *p는 p가 가리키는 메모리 주소로부터 sizeof(TYPE) 크기의 블록을 나타낸다.
*  

### 5.1.3.2 간접 멤버(->) - Arrow Operator
포인터의 원천 타입이 클래스일 경우 클래스 멤버를 나타내기 위하여 사용된다.
* 즉, 포인터가 가리키는 메모리 주소를 통해서 간접적으로 클래스 객체의 멤버를 나타낸다는 의미다.

### 5.1.3.3 증감(++, --) 연산자 - Increment & Decrement Operator
TYPE* 객체 p에 대해 p++는 p가 나타내는 주소보다 sizeof(TYPE) 크기만큼 큰 주소를 나타낸다.


### 5.1.3.4 첨자([]) 연산자 - Subscript Operator
첨자 연산자를 사용하면 포인터를 배열처럼 사용할 수 있다.
* 인덱스가 배열의 범위를 넘어서는 경우 잘못된 참조가 일어난다.
* 인덱스가 유효한 경우에만 사용하도록 주의를 기울여야 한다.

## 5.2 배열
배열은 같은 타입의 객체를 차례대로 메모리에 일렬로 모아놓은 자료구조이다.
* 배열에 포함된 객체를 요소(element)라고 부르는데 차례가 있다는 것은 각 요소에 순번이 있다는 의미이다.

### 5.2.1 배열 생성 및 초기화
배열 초기화란 배열 생성시 각 요소에 값을 설정하는 것이다.

초기화의 순서가 중요하다.
* 배열 객체가 생성된 뒤에 배열의 이름을 통해서 각 요소의 값이 설정되는 것이 아니라.
* 배열 객체가 메모리 블록을 형성할 때 요소의 값을 설정한 뒤에 블록에 이름을 붙이는 것이다.
* 배열 이름은 오직 주소를 나타내는 r-value로만 사용 가능한 이유기도 한다.

배열 초기화
~~~c++
int arr1[4] = {1};          // 1
int arr2[4] = {1, };        // 2
int arr3[4] = {0};          // 3
int arr4[4] = {};           // 4
int arr5[4] = {1, 2, 3};    // 5
int arr6[4] = {1, 2, 3, };  // 6
int arr7[4];                // 7
~~~
1. 1, 2는 인덱스 0 인 첫 요소만 1로 초기화되고 나머지는 0이된다.
2. 3, 4는 모든 요소를 0으로 초기화한다.
3. 5, 6은 1, 2, 3만 초기화되고 나머지를 0으로 초기화한다.
4. 7은 아예 초기화를 하지 않은 배열을 나타낸다.

모든 요소를 0이 아닌 특정한 값으로 설정하고 싶다면 어떻게 해야 할까?
* 초기화 블록에 1000번 같은 값을 써줘야할까?
* 초기화는 어쩔 수 없다.
* 배열 객체를 생성한 후에 값을 설정한다면 반복문을 통해 값을 설정해야만 할 것이다.
* int가 아닌 char나 BYTE와 같이 1바이트일 경우 memset을 이용하여 단일 값을 설정할 수 있다.

### 5.2.2 문자열 초기화
문자 배열의 초기화
~~~c++
char s1[] = {'A', 'B', 'C', '\0'};
char s2[] = "ABC";
char s3[] = {"ABC"};
~~~


## 5.3 다차원 배열
### 5.3.1 2차원 배열 구조
~~~c++
int arr[2][3] = {{11, 12, 13}, {21, 22, 23}};
~~~

arr l-value 불가\
arr[0] l-value 불가
1. 11 : arr[0][0]
2. 12 : arr[0][1]
3. 13 : arr[0][2]
 
arr[1] l-value 불가
1. 21 : arr[1][0]
2. 22 : arr[1][1]
3. 23 : arr[1][2]

### 5.3.2 포인터 대응
배열을 포인터처럼 혹은 포인터를 배열처럼 사용할 수 있다.
* 배열과 포인터를 완전히 일치하는 것처럼 생각하고 자유롭게 사용하는 것은 정말 위험한 프로그래밍 습관이다.

~~~c++
char s1[] = "ABC";
char *s2 = "ABC";
~~~

s1 = ABCD

s2 -> A(*s2) BCD

두 가지 경우는 완전히 다른 구조를 가지게 된다.
* s1은 배열이므로 "ABC"가 들어있는 메모리 블록 자체를 나타냄
* s2는 포인터로서 "ABC"가 들어있는 메모리 블록의 주소를 나타낼 뿐
* \* 연산자를 사용한 *s2는 char 타입이므로 오직 1바이트의 메모리 블록 영역을 나타낸다.

s1의 경우 상수 주소로 r-value로만 사용이 가능한데 s2는 l-value로 주소를 나타낸다.

1차원 배열의 경우 배열과 포인터를 호환해서 사용해도 큰 문제가 발생하지 않는다.


2차원 배열과 포인터 대응
~~~c++
int arr[2][3] = {{11, 12, 13}, {21, 22, 23}};
int **ppArr = (int**) arr;
cout << ppArr[1][2] << endl; // 1 Exception
~~~

* 위 예제에서는 예외가 발생하거나 23이 아닌 쓰레기 값이 출력될 수 있다.

ppArr은 int** 타입이다. 즉, 포인터의 포인터이다.
* 즉, ppArr이 가리키는 메모리 주소로부터 sizeof(int*) 크기 단위로 메모리 블록에 접근할 수 있다.

x86(4)과 x64(8)의 큰 차이점은 기본 타입 포인터의 크기가 다르다는 것이다.

x86 시스템
* 기본 타입 포인터의 크기가 4바이트다. sizeof(int*) = 4
* ppArr의 [] 연산으로 4바이트 씩 이동할 수 있다.
* ppArr[1] 에는 12라는 값이 들어있다.
* ppArr의 원천 타입은 int* 임으로 12라는 값을 int*로 해석하게 된다.
* 즉, 메모리 주소를 12라고 해석하는 것이다.
* 따라서 ppArr[1]을 [] 연산할 경우 12라는 주소로부터 sizeof(int)인 4바이트 단위로 이동하면서 메모리 블록에 접근할 ㅅ ㅜ있다.

이제 ppArr[1][2]는 무엇이 될까?
* Address 12인 위치에서 2 * sizeof(int) = 8바이트 떨어진 20이 될 것이다.
* 당연하게도 해당 영역에는 알 수 없는 값이 들어있다.
* 프로그램의 안정성을 위하여 보통 가상 메모리의 앞 부분의 영역은 메모리 접근이 금지된다.
* 데이터가 있었다면 아마도 예상치 못했던 쓰레기 값이 출력될 수도 있는 것이다.


2차원 배열과 포인터 대응 해결법
~~~c++
int arr[2][3] = {{11, 12, 13}, {21, 22, 23}};

int *arrP[2] = {arr[0], arr[1]}; // 1
int **ppArr = (int**)arrP;       // 2

cout << ppArr[1][2] << endl;
~~~

1. 1과 같이 int \*pArr[2]를 정의한다. arrP는 포인터가 아닌 int* 타입 포인터 두 개를 요소로 가지는 배열이다.
2. 2에서 ppArr은 앞의 arrP를 타입 변환하여 대입하는 것이다.


ppArr -> arr[0] -> 11\
ppArr[1] -> arr[1] -> 21 + 2 -> 23


### 5.3.3 배열 전달
배열을 함수의 인자로 전달하는 방법
* 배열은 오직 참조에 의한 호출로서 인자가 전달된다.

int arg[] 와 같은 표현이 인자에 사용될 경우 int*로 대체된다고 할 수 있다.
* 그러나 arg[][]와 같은 식은 허용되지 않는다.
* 따라서 이차원 배열을 전달받기 위해서는 int**가 되어야만 한다.
* 드러나 이차원 배열 이상은 배열과 호환이 잘 되지 않는다.
* 배열 참조 타입으로 인자를 전달하면 된다.

2차원 배열 인자 전달
~~~c++
int Func(int (&arg)[4])
{
    arg[0] = 1;
    arg[1] = 2;
    arg[2] = 3;
    arg[3] = 4;

    return sizeof(arg);
}

int main()
{
    int arr[4] = {0};
    int s = Func(arr);

    cout << arr[0] << endl;
    cout << arr[1] << endl;
    cout << arr[2] << endl;
    cout << arr[3] << endl;

    cout << "arr size : " << sizeof(arr) << endl;
    cout << "arg size : " << s << endl;
    return 0;
}
~~~

* 배열의 참조 타입을 전달하면 어떤 문제도 발생하지 않고 안전하게 사용할 수 있다.

## 5.4 배열의 크기
### 5.4.1 sizeof
sizeof() 연산자를 이용하면 배열의 크기를 구할 수 있다.

A : 배열의 크기 = sizeof(요소의 타입) * 요소의 개수
* 이렇게 할 필요 없다.
* sizeof 연산자는 배열 이름만 인자로 넣을 경우 배열의 크기를 구해준다.

B : 배열의 크기 = sizeof(배열 이름)
* B 식이 있기 때문에 A 식은 전혀 필요하지 않을 것 같다.
* 하지만 A 식을 응용하여 배열의 요소 개수를 구할 수 있다.

C : 배열의 요소 개수 = sizeof(배열 이름) / sizeof(요소의 타입)


~~~c++
int main()
{
    int arr[2][3];

    int s1 = sizeof(arr); // 24
    int s2 = sizeof(arr[0]); // 12
    int s3 = sizeof(arr[0][0];) // 4
}
~~~


sizeof 연산자는 인자의 값을 평가하는 것이 아닌 인자의 타입만을 평가한다.

2차원 배열 포인터의 경우

~~~c++
int arr[2][3];
int **ppArr = (int**)arr;

int s1 = sizeof(ppArr); // 4
int s2 = sizeof(ppArr[0]); // 4
int s3 = sizeof(ppArr[0][0]); // 4
~~~
* 포인터 타입의 사이즈만 계산

### 5.4.2 배열의 요소 개수
배열 요소의 개수가 정해지는 시점은 언제일까?
* C/C++ 코드가 작성되는 시점
* 배열 요소의 개수는 실행 중에 결정되어서는 안된다.

강제로 배열 요소의 개수를 변경해보는 예제
~~~c++
int main()
{
    const int count = 1024; // 1
    int *pCount = (int*)&count; // 2
    *pCount = 512; // 3

    int arr[count] = {0}; // 4
}
~~~
1. 2, 3은 강제로 const 타입의 값을 변경하는 예시이다.
2. 배열의 요소의 개수가 512개가 될까?
3. 컴파일러는 const가 지정된 변수를 거의 매크로처럼 취급해버린다.
4. 즉, 1번이 1024로 초기화되면 count를 그냥 1024로 취급한다.
5. 결국 배열 요소의 개수는 실행 시점에 결정될 수 없다.

### 5.4.3 가변 크기 배열(VLA : Variable-Length Array)
new[]를 통해서 가변 크기 배열이 이미 가능하지 않냐?
* 사실 이건은 메모리 블록의 포인터지, 배열 자체는 아니다.

일반적으로 배열 객체는 전역 객체가 생성되는 데이터 영역 혹은 스택에 주로 생성된다.

가변 크기 배열의 경우 데이터 영역과 힙에 생성되는 것은 사실 상 불가능하다.
* 오로지 스택에서만 생성 가능하다.

스택에 생성되는 배열의 경우 요소의 개수를 실행중에 결정하는 것은 어려운일이 아니다.
* 배열을 생성하는 어셈블리에서 정적으로 스택을 늘리는 alloca를 이용하여 대체하는 코드로 변경해주면 가능하다.

## 5.5 vector
* STL vector

### 5.5.1 배열과 vector
vector는 vector일 뿐 배열로 완벽히 대체가 될순 없다.
* vector가 기능적으로는 배열처럼 사용할 순 있겠지만 완벽하게 배열을 대체할 수는 없다.

배열을 인자로 받는 함수일 경우 vector를 넘길 수 없다.

vector의 포인터를 넘겨줘도 배열을 받는 경우 vector에서 쓰레기 값을 뱉을 수 있다.
* vector의 멤버 중 _Myfirst 포인터가 바로 실제 요소들이 시작되는 주소를 가리키고 있을 뿐이다.

### 5.5.2 vector 인자
배열의 경우 값에 의한 호출로 전달되어도 참조에 의한 호출처럼 취급된다.
* 배열의 이름이 포인터이기 때문에
* 배열 객체를 무조건 참조 방식으로 전달되게 만든 이유는
* 효율성 및 안정성을 위해서다. (스택 오버 플로우 방지)

vector는 클래스이다.
* 클래스의 인자 전달 방식을 따른다.
* 값에 의한 호출로 전달할 경우 복사 생성자가 호출되며 스택에 복사본이 생성된다.
* vector는 배열과 다르게 값에 의한 호출을 실제 복사에 의해서 처리한다.