# Chapter 01 - 타입 (Type)
## 1.1 디지털화
## 1.2 정수 타입
### 1.2.6 컴파일러 상수 한계

int max1 = 18446744073709551615;
* 상수 최댓값
int max2 = 18446744073709551616;
* Complie Error
int min1 = -18446744073709551615;
* 상수 최솟값
int min2 = -18446744073709551616;
* Complie Error

컴파일러는 소스 코드에 쓰여진 상수를 분석해서 실제 변수의 비트 값을 결정해서 어셈블리 코드로 쓴다.
* 그러나 컴파일러가 분석할 수 있는 한계가 있다.
* unsigned __int64 타입의 최대값이다.


### 1.2.7 데이터 모델

플랫폼별 데이터모델이 다르기 때문에 항상 타입의 크기가 일정하지 않다.

* char : short : int : long : long long : pointer
1. ILP32 : 8 16 32 32 64 32
2. ILP64 : 8 16 64 64 64 64
3.  LP64 : 8 16 32 64 64 64
4. LLP64 : 8 16 32 32 64 64

x86 32비트 시스템에서는 윈도우 리눅스 모두 ILP32 사용

x64 64비트 시스템에서는 윈도우 LLP64 리눅스 LP64
* 차이는 long 타입의 크기

### 1.2.8 long long format control
%lld or %I64d(VC++에서만 사용 가능)

## 1.3 부동소수점 타입
부동소수점은 아주 작은 수와 아주 큰 수 양쪽 모두 표현하기 위해 도입

### 1.3.1 고정소수점과 부동소수점
부동소수점은 소수점을 고정하지 않는 것
* 계산기가 한계를 넘어가면 e를 표시 : e가 바로 부동소수점, 즉 소수점 위치

### 1.3.2 부동소수점과 2진법
-9.6875를 2진법으로

-9는 1001

0.6875를 2씩 곱하며 계산

* 0.6975
* 1.375
* 0.375 ... 1
* 0.75  ... 0
* 1.5 
* 0.5   ... 1
* 1.0
* 0.0   ... 1

즉, 1001.1101로 표현된다.


### 1.3.3 부동소수점 구조
1001.1101을 정규화하는 과정을 거친다.

-1001.1011을 정규화하면
* -1.0011011 * 2 ^ 3

정규화란?
* 정수부분을 1로 맞추어 놓고 소수점 위치를 조정하는 것

### 1.7 참조 타입
C++에 도입된 개념
* 포인터를 사용하지 않고 같은 효과를 낼 수 있다.
* 사실 참조도 포인터를 사용하는 것에 불과하다.

어셈블리를 분석하면 완전히 동일하게 동작한다.


참조 타입 객체가 초기화 될 수 있는 이유
* 참조 타입 객체를 위한 메모리 공간이 확보되기 때문
* 초기화되는 과정은 포인터 영역이 마련되고, 초기화되는 변수의 주소가 포인터 영역에 써지게 된다.
* const 지정자가 있을 경우에는 포인터 영역 뿐 아니라 int 객체의 임시 영역이 마련되어 상수가 대입되고
* 해당 임시 영역의 주소가 포인터 영역에 써지게 된다.

Low
* ra = eax : esp
* a : esp = ebp-0Ch
* rc = ecx : ebp-8
* 2 : ecx = ebp-4
* ebp : ebp
High

sub esp, 10h : 스택에 16바이트 영역을 확보하라는 것
* 지역변수 a와 ra, rc 그리고 임시영역 Temp까지 총 4개의 4바이트 영역

ebp-0Ch : 변수 a의 위치

ebp-10h : 변수 a의 주소 : 즉 참조 변수 ra의 공간

ebp-4 : 임시 영역

ebp-8 : 참조 변수 rc 영역에 임시 영역의 주소 대입


### 1.7.2 우측 값 참조 (RValue Reference)
lValue : 지속되는 값

rValue : 유지되지 않는 임시 값

기존의 참조 타입은 lvalue의 참조를 의미
* 즉, 변수의 주소를 취하는 것

rvalue도 참조도 타입으로 쓸 수 있게 추가된 것

RValue의 목적?
* 우측 값에서 필요한 것은 재활용해서 효율을 높이겠다는 것
* 주로 클래스의 복사 생성자와 복사 대입 연산자에 사용되어 메모리 사용 효율을 높이는데 사용

## 1.8 typedef
### 1.8.1 유효 범위
* 함수 내에서 정의시 오직 함수내에서만 사용 가능

### 1.8.2 정의 방법
1. 원하는 타입을 선언한다.
2. 선언문 앞에 typedef를 붙인다.
3. 선언문의 객체 이름을 정의하고자 하는 타입 이름으로 변경한다.


typedef를 사용해서 함수 포인터 타입까지 정의할 수 있다.

typedef double (*PFUNCTYPE) (int arg1, int arg2);

1. 먼저 Divide와 같은 타입의 함수 포인터를 선언한다.
2. 선언문 앞에 typedef를 붙여준다.
3. 선언문의 객체 이름인 func를 정의하고자 하는 타입 이름 PFUNCTYPE으로 변경한다.

함수 이름을 괄호로 감싸고 이름 앞에 * 연산자를 붙이면 함수 포인터가 된다.

## 1.9 auto
### 1.9.1 자동 변수 auto
자동 변수는 단순히 지역 변수를 의미
* 함수 안에서만 사용 가능
* 지금은 삭제되었다.
* 최신 C++에서 auto는 새로운 의미로 부활하였다.

### 1.9.2 C++ auto
컴파일 타임에 자동으로 적절한 타입으로 변경되는 키워드다.

auto a = 1; // int a = 1;
* 변수가 1로 초기화되는데 1은 바로 int 타입으로 간주할 수 있기 때문

auto a;\
a = 1; // Compile Error
* auto 추론 실패
* auto가 타입을 추론하려면 선언 즉시 초기화되어야 함

auto가 &으로 추론되는 것은 아니다.
* 레퍼런스의 경우 &를 붙여주어야 함

### 1.9.3 auto 사용
타입 이름이 길 경우 매우 유용하다.
* 보통 STL 컨테이너와 함께 쓰인다.
* auto는 typedef를 사용하지 못하는 타입 (람다 타입) 또한 받을 수 있다.