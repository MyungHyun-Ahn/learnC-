# Chapter 03 빌드(Build)
## 3.1 빌드의 구성
빌드는 세 단계로 나눌 수 있다.
1. 전처리
2. 컴파일
3. 링크

정적 라이브러리를 만드는 경우 링크 과정이 필요하지 않다.

최종 바이너리를 만들기 위해 필요한 과정을 빌드라고 한다.


### 3.1.1 컴파일
컴파일은 가장 중요하다.

컴파일의 대상이 되는 파일은 바로 소스 파일, 즉 cpp 파일이다.
* 헤더 파일은 컴파일의 대상이 아니다.
* 오직 특정 cpp 파일 안의 #include 구문에 의해 포함될 뿐이다.

cpp 파일이 컴파일되면 목적(object)파일이 생긴다.
* 소스파일과 목적파일은 일대일 대응 관계이다.
* 소스파일을 기계어로 변환한 것이 목적 파일이다.

즉, 컴파일이란 cpp 파일을 기계어 파일로 변환하는 것을 의미한다.


### 3.1.2 링크
단일의 소스파일로 실행 파일을 만들 수 있다면 링크는 필요하지 않다.
* 대신 소스파일이 어마어마하게 커질 것이다.
* 보통 최종 바이너리가 만들어질 때까지 많은 수의 소스파일이 사용된다.

hello world 프로그램
* Main 파일 하나로 이뤄져있다?
* 전혀 그렇지 않다.
* printf 함수를 사용하기 위해 CRT Library를 사용해야 한다.
* CRT Library는 이미 수많은 cpp 파일이 컴파일되어 만들어진 목적파일로 이뤄져 있다.
  
즉, 최종 바이너리는 많은 목적파일이 적절히 연결되어있는 상태다.

printf.obj 파일이 프로세스 메모리에 올라간 주소로 변형시켜 주는 것이 바로 링크다.
* 간단하게 링크는 많은 목적파일들이 프로세스 메모리 가상 공간에 적재되었을 때 서로가 맞물릴 수 있도록 각각의 주소를 변경해주는 것을 의미한다.

### 3.1.3 전처리
~~~
// Main.cpp
void Func(char *str);

void main()
{
    Func("Hello World!");
}
~~~

위 예제를 빌드할 경우 에러가 발생한다.
* 빌드가 전처리, 컴파일, 링크 단계로 구성하므로
* 그 중 하나의 단계에서 발생한 것이다.
* 정답은 링크 에러다.

전처리와 컴파일 단계에서는 에러가 없었다는 의미다.
* Func 선언을 하여서 문제가 되지 않았다.

#include는 전처리 지시문이다.
* 해당 헤더파일을 보고 그대로 cpp 파일에 붙이는 역할을 수행한다.

결국 전처리란 컴파일 이전에 복사붙여넣기 작업 등을 편하게 수행할 수 있도록 전처리 지시문으로 기록하고, 컴파일이 가능하도록 원래 소스 구문을 복구하는 과정이다.


## 3.2 전처리 지시문

### #include
"" 형식과 <> 형식을 사용가능하다.

"" 형식일 경우
* #include 구문이 포함된 파일과 동일한 디렉터리를 탐색한다.
* 찾지 못하는 경우 /I 컴파일러 옵션에 지정된 경로를 따라 검색한다.
* /I 옵션이란 IDE의 포함 디렉터리에 지정된 경로다.
* 마지막으로 INCLUDE 환경 변수에 지정한 경로에서 찾는다.

<> 형식일 경우
* /I 옵션과 INCLUDE 환경 변수에 지정한 경로에서 검색한다.
* "" 형식이 좀 더 포괄적인 검색 범위를 가지고 있다.


#include에 사용되는 파일은 확장자에 상관없이 헤더 파일이라고 할 수 있다.
* 소스 파일에 그대로 붙여지기 때문이다.

링크를 통해 하나의 바이너리가 될 때 전역 변수와 전역 함수는 오직 하나만 존재해야 한다.
* 이런 문제로 헤더 파일을 작성할 때는 전역 변수나 전역 함수를 정의해서는 안된다.
* 오직 선언만 해야 한다.
* 전역 변수의 경우 extern 키워드를 붙여주고
* 함수의 경우 본체를 작성하지 않으면 된다.


### 3.2.2 #define
컴파일러에게 소스 파일에서 identifier가 나타낼 때마다 token-string으로 대체하도록 지시하는 역할을 한다.
* 물론 주석이나 문자열에 사용될 경우에는 대체하지 않는다.

대체가 되는 경우는 identifier가 컴파일 당시 토큰으로 사용될 경우뿐이다.

#define은 순서를 따지지 않는다.
* 전처리 과정에서 identifier가 대체되어 사라질 때까지 반복한다.

token-string은 생략될 수 있다.

정의만 한다는 것은 또다른 전처리 지시문인 #if defined 혹은 #if def를 통해서 테스트하는데 쓰겠다는 것이다.


함수 매크로


### 3.2.3 #undef
#undef는 #define에 의해서 정의된 매크로를 해제하는 역할을 한다.
* 대표적으로 placement new를 사용하기 위해 사용하기도 한다.

~~~
#define new DEBUG_NEW


void main()
{
    void *p = malloc(32);

#pragma push_macro("new")

#undef new
    char *pC = new (p) char;
#pragma pop_macro("new")

}
~~~

* new가 DEBUG_NEW 로 정의된 매크로일 경우 Placement new를 사용할 수 없다.
* 따라서 new를 사용하기 직전에 #undef 매크로로 매크로를 해제한다.
* 다 사용한 후에는 매크로를 다시 정의해야만 한다.

### 3.2.4 조건부 컴파일 지시문
조건부 컴파일 지시문은 #define으로 정의된 매크로를 기준으로 컴파일 여부를 결정하는 것이다.
* #if, #ifdef, #ifndef, #else, #elif, #endif 등이 사용된다.


### 3.2.5 #pragma once
헤더 파일 맨 앞에 쓰며 헤더 파일을 단 한번만 포함시키라는 의미다.
* 중복으로 헤더 파일이 포함될 수 없도록 막는 것이다.

#pragma once를 지원하지 않는 컴파일러의 경우
* 조건부 컴파일을 이용한다.

## 3.3 미리 정의된 매크로

### 3.3.1 ANSI 호환 미리 정의된 매크로
\_\_FILE__, __LINE__이 있다.
* 로그를 남길 때 주로 사용한다.
* \_\_FILE__은 파일명
* __LINE__은 소스코드 라인 번호

\_\_FUNCTION__은 함수 이름 매크로


### 3.3.2 컴파일러 전용 미리 정의된 매크로

## 3.4 미리 컴파일된 헤더
헤더가 중복되게 인클루드 되는 경우 중복작업이 많이 발생한다.
* 단 한번만 처리되게 만들어야 한다.
* 그래서 미리 컴파일된 헤더가 나왔다.
* 컴파일 속도를 빠르게 할 수 있다.

소스 파일에서는 미리 컴파일된 헤더(pch)만 추가하면 컴파일 시간을 대폭 줄일 수 있다.


## 3.5 링크 에러
### 3.5.1 확인할 수 없는 외부 참조
* 함수의 본체를 찾을 수 없는 경우
* 보통 소스 파일은 있지만 프로젝트에 추가되지 않았기 때문에 발생하는 경우가 많다.

### 3.5.2 여러번 정의된 기호
* 함수 정의가 중복된 경우
* 보통 같은 종류의 라이브러리를 사용할 경우 발생할 수 있다.
* namespace를 사용하여 충돌이 발생하지 않도록 정리하여 해결할 수 있다.