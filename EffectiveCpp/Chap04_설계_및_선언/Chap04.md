# 04 설계 및 선언
## 항목 18: 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자
## 항목 19: 클래스 설계는 타입 설계와 똑같이 취급하자
새로 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야 하는가?
* 이부분에 따라 클래스 생성자 및 소멸자의 설계가 바뀜

객체 초기화는 객체 대입과 어떻게 달라야 하는가?
* 초기화와 대입을 구분하자

새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가?
* 값에 의한 전달을 구현하는 쪽은 복사 생성자

새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가?

기존의 클래스 상속 계통망에 맞출 건인가?

어떤 종류의 타입 변환을 허용할 것인가?

어떤 연산자와 함수를 두어야 의미가 있을까?

표준 함수들 중 어떤 것을 허용하지 말 것인가?

새로운 타입의 멤버에 대한 접근권한을 어느 쪽에 줄 것인가?

선언되지 않은 인터페이스로 무엇을 둘 것인가?

새로 만드는 타입이 얼마나 일반적인가?

정말로 꼭 필요한 타입인가?

## 항목 20: 값에 의한 전달보다는 상수객체 참조자에 의한 전달 방식을 택하는 편이 대개 낫다

## 항목 21: 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자
지역 스택 객체에 대한 포인터나 참조자를 반환하는 일, 혹은 힙에 할당된 객체에 대한 참조자를 반환하는 일, 또는 지역 정적 객체에 대한 포인터나 참조자를 반환하는 일은 그런 객체가 두 개 이상 필요해질 가능성이 있다면 절대로 하지 말 것

## 항목 22: 데이터 멤버가 선언될 곳은 private 영역임을 명심하자

## 항목 23: 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자
캡슐화 정도가 높아지고 패키징 유연성도 커지며 기능적인 확장성도 늘어난다

## 항목 24: 타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수를 선언하자
어떤 함수에 들어가는 모든 매개변수에 대해 타입 변환을 해 줄 필요가 있다면 그 함수는 비멤버

## 항목 25: 예외를 던지지 않는 swap에 대한 지원도 생각해보자
* std::swap이 느리게 동작할 여지가 있다면 예외를 던지지 않는 swap 멤버 함수를 제공하자
* 멤버 swap을 제공했으면 이 멤버를 호출하는 비멤버 swap 도 제공, std::swap도 특수화하자
* 사용자 입장에서 swap을 호출할 때는 using 선언을 넣어준 후 swap을 호출
* 사용자 정의 타입에 대한 std 템플릿을 특수화 하는 것은 가능, 그러나 std에 추가하려 하진 말자