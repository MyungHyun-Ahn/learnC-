# 01 C++에 왔으면 C++의 법을 따릅시다.
## 항목 1: C++를 언어들의 연합체로 바라보는 안목은 필수
C++의 하위 언어 4가지
* C
* 객체 지향 개념의 C++
* 템플릿 C++
* STL

이것만은 잊지 말자!
* C++를 사용한 효과적인 프로그래밍 규칙은 경우에 따라 달라짐
* 그 경우란 C++의 어떤 부분을 사용하느냐

## 항목 2: #define을 쓰려거든 const, enum, inline을 떠올리자
"가급적 전처리기보다 컴파일러를 더 가까이 하자"
* #define은 전처리 타임
  * 언어 자체의 일부가 아닌 것으로 취급
  * 컴파일러는 전혀 알수없다.
* 나머지는 컴파일 타임

이것만은 잊지 말자!
* 단순한 상수를 쓸 때는, #define 보다 const 객체 혹은 enum을 우선 생각
* 함수처럼 쓰이는 매크로를 만드려면 inline 함수를 우선 생각

## 항목 3: 낌새만 보이면 const를 들이대 보자!
const 멤버 함수는 오버로딩의 대상
* const 객체는 const 버전 호출
* non const 객체는 non const 객체 버전 호출

실제 프로그램에서 const 객체가 생기는 경우
* const 객체에 대한 포인터
* const 객체에 대한 참조로 객체가 전달될 때

비트수준 상수성
* 그 멤버 함수가 const 임을 인정하는 개념
* 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 함
* 객체의 어떠한 비트도 변하면 안됨

논리적 상수성
* 객체의 일부 몇 비트는 바꿀 수 있되 사용자 측에서 알아차리지 못하게 함

컴파일러의 비트 수준 상수성 검사를 피하는 방법
* mutable 키워드
* const의 반대 개념

이것만은 잊지 말자!
* const를 붙여 선언하면 컴파일러가 사용상의 에러를 잡아내는 데 도움을 줌
* 컴파일러 쪽에서 보면 비트 수준 상수성을 지켜야 하지만, 우리는 논리적 상수성을 이용하여 프로그래밍해야 함
* 상수 멤버 및 비상수 멤버 함수가 기능적으로 똑같이 구현되어야 한다면, 비상수 버전이 상수 버전을 호출하도록 만들어야 함

## 항목 4: 객체를 사용하기 전에 반드시 그 객체를 초기화하자
대입과 초기화는 다르다.
* 생성자 스코프에서 대입 - 대입, 초기화가 아니다.
* 생성자 이니셜라이저 - 초기화

객체를 구성하는 데이터의 초기화 순서
1. 기본 클래스는 파생 클래스보다 먼저 초기화
2. 클래스 데이터 멤버는 선언 순서대로 초기화


서로 다른 코드에 선언된 비지역 정적 객체들 사이의 초기화 순서는 정해지지 않음
* 비지역 정적 객체를 맡는 함수를 준비하고 그 안에서 순서를 정해줌
* 비지역 정적 객체가 -> 지역 정적 객체로 바뀐 것
  * singleton pattern
  * GetInstance 호출 시점에 초기화

이것만은 잊지 말자!
* 기본 제공 타입의 객체는 직접 초기화
* 생성자에서는 생성자 이니셜라이저를 사용
* 비지역 static 객체의 초기화 순서 문제는 피해서 설계하자