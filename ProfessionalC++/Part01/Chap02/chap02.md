# Chater 02 스트링과 스트링 뷰 다루기
C언어를 사용하던 시절에는 단순히 null로 끝나는 문자 배열로 스트링을 표현했다.
* 이렇게 처리하면 오버플로를 비롯한 다양한 문제를 마주쳐 보안 취약점이 드러날 수 있다.

C++ 표준 라이브러리는 이러한 문제를 방지하기 위해 std::string 클래스를 제공한다.

## 2.1 동적 스트링
### 2.1.1 C 스타일 스트링
C언어는 스트링의 마지막에 '\0' 널 문자로 스트링이 끝났음을 표현
* 널 문자의 공식 기호는 NUL

strlen() 에서 반환한 길이는 str을 저장한 메모리 크기가 아닌 스트링 길이라는 점에서 문제가 발생한다.
* 따라서 +1을 더한 값을 문자의 크기로 지정해야 한다.

C/C++에서 제공하는 sizeof 연산자는 실제 스트링에 할당된 메모리 크기를 반환한다.
* 만약 char*로 저장했다면 포인터의 크기를 반환한다.

C 스타일 스트링 연산에 관련된 함수는 <cstring> 헤더 파일에 저장되어 있다.
* 마이크로 소프트 비쥬얼 스튜디오에서는 C 스타일 스트링 함수를 사용할 때 경고를 발생시킨다.
* _s가 붙은 함수를 사용하면 된다.

### 2.1.2 스트링 리터럴
"Hello" 와 같이 변수에 담지 않고 곧바로 값으로 표현한 것을 스트링 리터럴이라고 한다.
* 내부적으로 메모리의 읽기 전용 영역에 할당된다.

"Hello"라는 스트링 리터럴을 500번 넘게 작성해도 컴파일러는 Hello의 메모리 공간을 딱 하나만 할당한다,
* 이를 리터럴 풀링(literal pooling)이라 한다.

스트링 리터럴을 변수에 대입할 순 있지만, 메모리의 읽기 전용 영역에 있거나 동일한 리터럴을 공유할 수 있기 때문에 위험하다.

char *ptr = "hello";\
ptr[1] = 'a';
* 결과를 예측할 수 없다.

따라서 스트링 리터럴을 참조할 경우 const 문자 포인터를 사용하는 것이 안전하다.

const char *ptr = "hello";\
ptr[1] = 'a';
* 읽기 전용 메모리에 값을 쓰기 때문에 에러

char[] 문자 배열의 초깃값을 설정할 때도 스트링 리터럴을 사용한다.
* 컴파일러는 주어진 스트링을 충분히 담을 정도로 큰 배열을 생성한 뒤에 여기에 실제 스트링 값을 복사한다.
* 컴파일러는 이렇게 만든 스트링 리터럴을 읽기 전용 메모리에 넣지 않으며 재사용하지 않는다. -> 충분히 담을 정도? 틀린 내용 같음

char arr[] = "hello";\
arr[1] = 'a';
* 스트링을 수정할 수 있다.


### 로 스트링 리터럴(raw string literal)
여러줄로 작성된 스트링 리터럴
* \t나 \n 과 같은 이스케이프 시퀀스를 일반 텍스로 취급한다.
* 줄바꿈을 그냥 엔터를 사용하면 된다.

const char* str = R"(Hello "World")";

* 로 스트링 리터럴은 )"로 끝나기 때문에 )"를 문자 중간에 넣을 수 없다.


### 2.1.3 C++ std::string 클래스
std::string은 basic_string이라는 클래스 템플릿의 인스턴스로 \<cstring>의 함수와 기능은 비슷하지만 메모리 할당 작업을 처리해주는 기능이 더 들어가 있다.

### C 스타일 스트링의 문제점
장점
* 간단하다. 내부적으로 기본 문자 타입과 배열 구조체로 처리한다.
* 가볍다. 제대로 사용하면 메모리를 꼭 필요한 만큼만 사용한다.
* 로우 레벨이다. 따라서 메모리의 실제 상태를 조작하거나 복사하기 쉽다.

단점
* 스트링 데이터 타입에 대한 고차원 기능을 구현하려면 상당한 노력이 필요하다.
* 찾기 힘든 메모리 버그가 발생하기 쉽다.
* C++의 객체지향적인 특성을 제대로 활용하기 어렵다.
* 프로그래머가 내부 표현 방식을 이해해야 한다.

### string 클래스 활용법
string은 실제로 클래스지만 마치 기본 타입인 것처럼 사용한다.
* C++ string에 연산자 오버로딩을 적용하면 C 스타일보다 사용하기 훨씬 편하다.


1. 스트링을 할당하는 코드나 크기를 조절하는 코드가 여러 군데 흩어져 있어도 메모리 누수가 발생하지 않는다.
    * 스택 변수이기 때문에

2. 연산자를 원하는 방식으로 작동하게 할 수 있다.

3. c_str() 메서드를 사용하면 C언어에 호환성을 보장할 수 있다.
    * 함수 내부에서 생성된 스택 기반 string 객체에 대해서는 c_str()의 결과를 절대로 반환하면 안된다.

string에서 제공하는 메서드는 c_str()은 const char* 타입을 리턴한 반면\
non-const 스트링에 대해 호출하면 char*를 반환한다.

### std::string 리터럴
* auto string1 = "Hello"; : const char*
* auto string2 = "World"s; : std::string

표준 사용자 정의 리터럴 s를 사용하려면 using namespace std::string_literals; 혹은 using namespace std;를 추가한다.

또한 std::string 은 다양한 헬퍼 함수를 제공한다.
* string to_string(); : 다양하게 오버로딩 되어 있어 다양한 타입을 제공한다.

### 로우 레벨 숫자 변환
C++17 부터 로우 레벨 숫자 변환에 대한 함수도 다양하게 제공된다.
* 이 함수는 메모리 할당에 관련된 작업은 전혀해주지 않기 때문에
* 호출한 쪽에서 버퍼를 할당해주어야 한다.
* 숫자 데이터와 사람이 읽기 좋은 포맷(Json, XML 등) 사이의 변환 작업을 로케일에 독립적이면서 빠른 속도로 처리 가능하다.

정수를 문자로 변환하는 함수

to_chars_result to_chars(char* first, char* last, IntegerT value, int base = 10);
* IntegerT 자리에 부호 있는 정수나 부호 없는 정수 또는 char 타입이 나올 수 있다.

to_chars_result 구조체 정의

struct to_chars_result {\
&nbsp;&nbsp;&nbsp;&nbsp;char *ptr;\
&nbsp;&nbsp;&nbsp;&nbsp;errc ec;\
};

* 정상적으로 변환 됐다면 ptr 멤버는 끝에서 두 번째 문자를 가리키고
* 아닌 경우 last 값과 같다.

다양하게 오버로딩 되어있기 때문에 부동소숫점 타입 또한 제공한다.

반대 방향 즉 스트링을 숫자로 변환하는 함수도 있다.

from_chars_result from_chars(const char *first, const char *last, IntegerT& value, int base = 10);


### std:string_view 클래스
C++17 이전에는 읽기 전용 스트링을 받는 함수의 매개변수 타입을 쉽게 결정할 수 없었다.

const std::string&을 매개변수로 지정하면 항상 std::string만 사용해야 한다.
* 간혹 함수의 오버로딩 버전을 여러개 만들기도 하는데 세련된 방법은 아니다.

C++17 부터 추가된 string_view 클래스를 사용하면 고민을 해결할 수 있다.
* string_view는 실제로 const string& 대신 사용할 수 있으며 오버헤드도 없다.

