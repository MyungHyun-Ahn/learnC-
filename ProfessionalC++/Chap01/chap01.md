# 1장 C++와 표준 라이브러리 초단기 속성 코스
모르는 것들을 정리해나갈 예정이다.
## 1.1 C++의 기초
### 전처리 지시자
C++로 작성된 소스코드의 빌드 작업은 세 단계를 거친다.
1. 전처리 : 소스 코드에 담긴 메타 정보를 처리
2. 컴파일 : 소스 코드를 머신이 읽을 수 있는 오브젝트 파일로 변환
3. 링크 : 앞에서 변환한 여러 오브젝트 파일을 애플리케이션으로 엮는다.


전처리 지시자(#define)은 헤더 파일에 있는 내용을 현재 파일에서 사용할 수 있도록 전처리기에 지시한다.

헤더 파일은 주로 나중에 소스 파일에서 구현할 함수를 선언하는 용도로 사용된다.
1. 함수의 선언부(declaration) : 함수의 호출 방식, 매개변수의 개수, 타입, 리턴 타입 등만 컴파일러에 알려주고
2. 구현부(정의부 definition) : 그 함수가 수행할 동작을 여기에 작성


* C에서는 표준 라이브러리의 헤더 파일을 표현할 때는 .h 확장자로 표기
* C++에서는 네임스페이스에 정의하고 네임스페이스를 불러온다.

자주 사용하는 전처리 지시자
1. #include 
2. #define [키] [값]
3. #ifdef[키] #endif
4. #ifndef[키] #endif
5. #pragma

중복 인클루드를 막기위한 전처리 지시자의 예

#ifndef HEADER\
#define HEADER\
// 헤더 파일에 담을 내용\
#endif

컴파일러에서 #pragma once 를 지원한다면 사용 가능

### 네임스페이스
코드에서 이름이 서로 충돌하는 문제를 막기 위해 나온 개념

스코프 지정 연산자
* abc::test(); : abc 네임스페이스에 지정된 test 함수를 호출한다.

using 지시자
* using namespace std; : 앞으로 나올 함수들이 std 네임스페이스에 있다는 것을 지시한다.
* using 지시자를 남발하면 결국 네임스페이스를 사용하지 않는 것과 같아진다.

만약 std 네임스페이스에서 cout 만 사용하고 싶다면
* using std::cout;

헤더 파일 내에서는 절대로 using 문을 사용하면 안된다.
* 그 헤더 파일을 인클루드하는 모든 파일에서 using 문으로 지정한 방식으로 인식

C++ 17 부터는 중첩된 네임스페이스(nested namespace)를 좀 더 쉽게 사용할 수 있도록 개선
* namespace a::b::c {}

네임스페이스 앨리어스(namespace alias)를 사용하여 기존 이름을 짧게 단축 가능
* namespace abc = a::b::c;


### 엄격한 열거 타입
C언어의 enum은 타입을 엄격하게 따지지 않는다.
* 타입을 엄격하게 따지는 것을 스트롱 타입, 타입 세이프하다라고 표현

enum class 
* enum class로 정의한 열거 타입은 스코프(유효 범위)가 자동으로 확장되지 않는다.
* enum class로 정의한 열거 타입은 자동으로 정수 타입으로 변환하지 않는다.

enum class ace : unsigned int {}
* 위와 같은 형식으로 열거 타입의 형식을 지정해줄 수 있다.

열거 타입을 사용할 때는 enum보다는 타입에 엄격한 enum class를 사용하는 것이 좋다.

## 조건문
### if 문의 이니셜라이저
C++17에서 추가된 if문의 이니셜라이저

if (<이니셜라이저>; <조건문>) { }
* 이니셜라이저에서 정의한 변수는 조건문과 본문 내에서만 사용할 수 있고 if문 밖에서는 사용할 수 없다.

### switch 문
switch 문에 지정할 수 있는 표현식은
* 정수 타입이거나, 정수로 변환 가능하거나, 열거 타입이거나, 엄격한 열거 타입이어야 한다.
* 또한 상수와 비교 가능해야 한다.

switch 문에서 break 가 없을 때\
흘려보내는 방식을 폴스루(fallthrough)라고 한다.
* C++17부터 switch문에서 폴스루 구문을 발견하면 경고메시지를 띄운다.
* [[fallthrough]]라는 속성을 지시해서 컴파일러에게 알려줄 수 있다.

C++17 부터 switch문에 이니셜라이저를 지정할 수 있다.
* switch (<이니셜라이저>; <표현식>) { }


## 함수
### 현재 함수 이름 출력
\_\_func\_\_ : 함수 내부적으로 로컬 변수가 지정되어 있다.


## 배열
### C스타일 배열과 std::array
둘 다 크기가 고정되므로 반드시 컴파일 타임에 결정되어야 한다.


### std::vector 동적 배열

### 이니셜라이저 리스트 (initializer_list)
* <initializer_list> 헤더 파일에 정의되어 있다.
* 이것을 활용하면 여러 인수를 받는 함수를 쉽게 작성할 수 있다.

int makeSum(initializer_list<int> lst);

int a = makeSum({1, 2, 3});

* 이니셜라이저 리스트는 타입세이프하다.
* 함수를 정의할 때 특정 타입만 들어가도록 지정하였다.


## 1.2 C++의 고급 기능
### const의 다양한 용도
1. const 상수 : C++에서 상수를 정의할 때는 const로 정의하는 것이 바람직하다.

2. const 매개변수 : 다른 함수에서 해당 값을 변경하지 않도록 지정

### 타입추론
1. auto 키워드
    * 리턴 타입을 추론
    * 구조적 바인딩에 사용
    * 표현식의 타입을 추론
    * 매개변수의 타입을 추론
    * decltype(auto)
    * 함수에 대한 또 다른 문법으로 사용
    * 제네릭 람다 표현식에서 사용

* auto를 지정하면 레퍼런스와 const 지정자가 사라진다.

2. decltype 키워드
    * 인수로 지정한 표현식의 타입을 알아낸다.

int x = 123;\
decltype(x) y = 345;
* y가 x의 int 타입임으로 추론

decltype 지시자는 const와 레퍼런스를 삭제하지 않는다.
* 템플릿을 사용할 때 상당히 강력한 효과를 발휘한다.

