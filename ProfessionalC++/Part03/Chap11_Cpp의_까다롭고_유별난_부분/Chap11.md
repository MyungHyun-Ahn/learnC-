# Chapter 11 C++의 까다롭고 유별난 부분
## 11.1 레퍼런스
C++에서 레퍼런스 : 일종의 변수에 대한 앨리어스(alias 별칭)

### 11.1.1 레퍼런스 변수
레퍼런스 변수는 반드시 생성하자마자 초기화해야 한다.

int x = 3;\
int& xRef = x;
* xRef는 x에 대한 일종의 별칭이다.
* xRef에 어떤 값을 대입하면 x의 값 또한 바뀐다.
* 레퍼런스 변수를 클래스 밖에서 선언만 하고 초기화하지 않으면 컴파일 에러가 발생한다.

정수 리터럴과 같이 이름 없는 값에 대해서는 레퍼런스를 생성할 수 없다.

int& unnamedRef1 = 5; // 컴파일 에러\
const int& unnamedRef2 = 5 // 정상 작동;
* const 레퍼런스로는 이름 없는 값을 받을 수 있다.
* 임시 객체 또한 마찬가지다.

레퍼런스 대상 변경하기
* 레퍼런스는 처음 초기화할 때 지정한 변수만 가리킨다.

int x = 3, y = 4;\
int& xRef = x;\
xRef = y;
* y 레퍼런스로 바뀌는 것이 아닌 y의 값(4)이 대입된다.

레퍼런스를 처음 선언하면 그 레퍼런스가 가리키는 변수를 변경할 수 없고 그 변수의 값만 바꿀 수 있다.

포인터에 대한 레퍼런스와 레퍼런스에 대한 포인터
* 레퍼런스는 모든 타입에 대해 만들 수 있다.
* 포인터 타입을 가리키는 레퍼런스도 만들 수 있다.
* 레퍼런스의 주소는 값에 대한 포인터와 같다.
* 레퍼런스에 대한 레퍼런스는 선언할 수 없다. (int& &, int&* 불가능)

### 11.1.2 레퍼런스 데이터 멤버
* 반드시 생성자의 본문이 아닌
* 생성자 이니셜라이저에서 초기화해야 한다.
  
### 11.1.3 레퍼런스 매개변수
* 레퍼런스 변수나 레퍼런스 멤버를 별도로 선언해서 사용하는 일은 많지 않다.
* 레퍼런스는 주로 함수나 메서드의 매개변수로 많이 사용된다.

매개변수는 전달받은 인수를 값 전달 방식으로 받기 때문에
* 즉, 복사본을 받는다.
* 내부에서 값을 수정해도 원본의 값은 변하지 않는다.

레퍼런스로 전달받은 매개변수는 레퍼런스 전달 방식으로 받는다.
* 원본의 값을 수정할 수 있다.
* 단 일반 레퍼런스 변수를 상수로 초기화할 수 없듯이.
* non-const 레퍼런스 전달 방식을 사용하는 함수의 인수로 상수를 전달할 수 없다.

포인터를 레퍼런스로 전달하기.
* 포인터를 레퍼런스로 변환할 수 있다.

int x = 5, y =6;\
int *xp = &x, *yp = &y;\
swap(*xp, *yp);


레퍼런스 전달 방식과 값 전달 방식
* 레퍼런스 전달 방식의 장점
  1. 효율성 : 크기가 큰 객체는 복제 오버헤드가 크가. 레퍼런스 전달 방식은 객체의 레퍼런스만 전달한다.
  2. 정확성 : 값 전달 방식을 지원하지 않는 객체가 있다. 지원하더라도 깊은 복제가 적용되지 않을 수 있다.

원본 객체는 수정할 수 없게 만들려면 매개변수를 const 레퍼런스로 선언하면 된다.
* 값 전달 방식의 장점을 고려하면 기본 타입이면서 함수 안에서 수정할 필요가 없을 때만 사용하고
* 나머지 경우는 레퍼런스 전달 방식이나 const 레퍼런스 전달 방식을 사용하는 것이 좋다.

### 11.1.4 레퍼런스 리턴값
함수나 메서드의 리턴값도 레퍼런스 타입으로 지정할 수 있다.
* 효율성 때문
* 객체에 대한 레퍼런스만 리턴하면 복제 연산을 줄일 수 있다.
* 물론 함수 종료 후에도 남아 있는 객체에 대해서만 레퍼런스로 리턴할 수 있다.


### 11.1.5 rvalue 레퍼런스
lvalue : 변수처럼 이름과 주소를 가지면서 대입문의 왼쪽에 나온다.\
rvalue : lvalue가 아닌 나머지를 말한다.

### 11.1.6 레퍼런스와 포인터의 선택 기준
* 포인터를 사용하여 코드를 작성하면 코드가 복잡해진다.
* 레퍼런스의 값은 널이 될 수 없고, 명시적으로 역참조할 수도 없다.
* 단, 포인터가 하나도 없을 때만 레퍼런스가 더 안전하다고 말할 수 있다.

포인터를 사용한 코드는 거의 대부분 레퍼런스로 표현할 수 있다.\
반드시 포인터로 표현해야하는 경우
* 변수가 가리키는 주솟값을 변경해야하는 경우 : 레퍼런스 타입의 변수는 한번 초기화하면 가리키는 대상을 변경할 수 없다.
* 동적 할당 메모리의 주소는 레퍼런스가 아닌 포인터에 저장해야 한다.
* 주솟값이 nullptr가 될 수도 있는 optional 타입은 반드시 포인터를 사용해야 한다.
* 컨테이너에 다형성 타입을 저장할 때도 포인터를 사용해야 한다.

매개변수나 리턴값을 포인터와 레퍼런스 중 어느 것으로 표현하는 것이 적합한지 판단하는 방법
* 메모리의 소유권이 어디에 있는지.
* 메모리의 소유권이 변수를 받은 코드에 있으면 객체에 대한 메모리를 해제하는 책임은 그 코드에 있다.
  * 포인터, 기왕이면 스마트 포인터
* 메모리 소유권이 변수를 받는 코드에 없어서 메모리 해제할 일이 없다면
  * 레퍼런스

포인터보다 레퍼런스를 사용하는 것이 좋다. 레퍼런스를 사용할 수 없을 때만 포인터를 사용한다.      


## 11.2 키워드 혼동
C++에서 가장 헷갈리기 쉬운 키워드는 const와 static이다.

### 11.2.1 const 키워드
const 변수와 매개변수
* const를 변수에 붙이면 그 값이 변하지 않게 보호할 수 있다.
* 본문 안에서 const 매개변수를 수정하려 하면 컴파일 에러가 발생한다.

const 포인터
* 포인터로 가리키는 값이 수정되지 않게 하려면 다음과 같이 한다.
* const int *ip;
* int const *ip;
* 변경하지 않는 값이 포인터 주소 자체라면 다음과 같이 한다.
* int * const ip;
* 둘 다 라면
* const int * const ip;

const 레퍼런스
* 레퍼런스는 기본적으로 const 속성을 가지고 있다. const_cast를 통한 const 속성 제거 가능
* const int& zRef = z;
* zRef의 값을 변경하려하면 컴파일 에러
* 주로 레퍼런스 매개변수를 전달하고 값을 변경하지 않게 만들 때 사용한다.

const 메서드
* 클래스 메서드를 const로 지정할 수 있다.
* mutable로 선언하지 않은 데이터 멤버는 변경할 수 없다. - const 함수 내부에서 값을 변경하고 싶을 때 mutable

constexpr 키워드
* constexpr 키워드를 사용하면 해당 함수를 상수 표현식으로 다시 정의한다.
  * 컴파일 시간에 평가된다. : 내부적으로 inline 처리 : 컴파일러가 판단하게 안될수도 있음

함수에 constexpr을 적용했을 때 제약사항
* 함수 본문에서 goto, try catch, 초기화하지 않은 변수, 리터럴 타입이 아닌 변수 정의 등이 없어야 하고, 익셉션을 던져도 안된다.
* 다른 constexpr 함수를 호출할 수는 있다.
* 리턴 타입이 반드시 리터럴 타입이어야 한다.
* constexpr 함수의 매개변수는 반드시 리터럴 타입이어야 한다.
* 컴파일러는 항상 모든 정의를 완전히 알아야 컴파일할 수 있으므로 constexpr 함수의 구현 코드를 컴파일러가 해석하기 전까지 호출할 수 없다.
* dynamic_cast와 reinterpret_cast를 사용할 수 없다.
* new 와 delete를 사용할 수 없다.

사용자 정의 타입의 상수 표현식 변수 만들기
* constexpr 생성자 정의

제약사항
* 가상 베이스 클래스를 가질 수 없다.
* 생성자의 매개변수가 모두 리터럴
* try 블록을 만들 수 없다.
* 생성자 본문을 디폴트로 지정하거나, constexpr 함수의 본문과 똑같은 요구사항을 만족해야 한다.
* 모든 데이터 멤버를 상수 표현식으로 초기화해야 한다.


### 11.2.2 static 키워드
static 데이터 멤버와 메서드
* static으로 선언한 멤버는 객체가 아닌 클래스에 속한다.
* static 메서드는 특정 객체를 통해 실행되지 않는다.

static 링크
* static을 선언하면 내부 링크가 적용된다.
* 같은 파일에서만 사용할 수 있다.

익명 네임스페이스를 이용하면 내부 링크가 적용된다.
* 내부 링크를 사용할 때는 static 보다는 익명 네임스페이스가 바람직하다.


extern 키워드
* static과 정반대로 외부 링크를 지정할 때 사용하는 것과 같다.
* const와 typedef는 기본적으로 내부 링크로 처리된다.
* 여기에 extern을 붙이면 외부 링크가 적용된다.
* extern을 지정하면 컴파일러는 이를 정의가 아닌 선언문으로 취급한다.

전역 변수는 사용하지 않는 것이 좋다.
* 코드가 커질수록 이해하기 힘들고 에러가 발생하기 쉽기 때문이다.

함수 안의 static 변수
* 특정 스코프 안에서만 값을 유지하는 로컬 변수를 만드는 것이다.
* 함수 안에서 static으로 지정한 변수는 그 함수만 접근할 수 있는 전역 변수와 같다.
* 주로 메이어의 싱글톤 패턴을 만들 때 용이하다.

### 11.2.3 비로컬 변수의 초기화 순서
* 표준에 정해져 있지 않아서 알 수 없다.
* 소멸 순서는 이의 역이다.

## 11.3 타입과 캐스팅
### 11.3.1 타입 앨리어스
* 기존에 선언된 타입에 다른 이름을 붙이는 것
* 너무 복잡하게 선언된 타입 표현을 좀 더 간편하게 만들기 위한 용도로 많이 사용


### 11.3.2 함수 포인터에 대한 타입 앨리어스
* C++에서는 함수를 데이터로 취급할 수 있다.
* std::function을 활용하는 방법도 있다.

### 11.3.3 메서드와 데이터 멤버를 가리키는 포인터에 대한 타입 앨리어스
int (Employee::*methodPtr) () const = &Employee::getSalary;\
cout << (employ.*methodPtr)() >> endl;


### 11.3.4 typedef
* 선언하는 순서가 반대기 때문에 헷갈리기 쉽다.
* 템플릿에 활용하는 경우 typedef보다 using이 훨씬 유리하다.


### 11.3.5 캐스팅
C++은 const_cast, static_cast, reinterpret_cast, dynamic_cast 네 가지 방법을 제공한다.

const_cast
* 변수에 const 속성을 추가하거나 제거할 때 사용한다.
* 네 가지 캐스팅 중 const_cast만 const를 제거할 수 있다.

as_const : C++17
* \<const> : as_const() 함수로 const 속성을 부여할 수 있다.
* auto와 as_const()를 조합하면 auto에서 const 타입을 떼버린다.

static_cast
* 언어에서 제공하는 명시적 변환 기능을 수행
* 상속 계층에서 다운 캐스팅을 수행할 때도 static_cast를 사용한다.
* 런 타임에 타입 검사를 수행하지 않는다.
* 실제로 관련이 없는 경우에도 타입 검사를 수행하지 않고 포인터나 레퍼런스로 변경한다.
* 기본적으로 C++의 타입 규칙에서 허용하지 않는 것은 모두 할 수 없다고 보면 된다.

reinterpret_cast
* static_cast보다 강력하지만 안전성은 떨어진다.
* 아무런 관련 없는 타입 또한 변환이 가능한다.
* void*로 변환한 것을 다시 원래 타입으로 캐스팅할 때는 reinterpret_cast를 사용해야 한다.


dynamic_cast
* 같은 상속 계층에 속한 타입끼리 캐스팅할 때 런타임에 타입을 검사한다.
* 적합하지 않은 경우 std::bad_cast 익셉션을 발생시킨다.


캐스팅 정리
1. const 속성 제거 : const_cast
2. 언어에서 허용하는 명시적 변환(int -> double 등) : static_cast
3. 사용자 정의 생성자나 변환 연산자에서 지원하는 명시적 변환 : static_cast
4. 서로 관련없는 객체끼리 변환 : 불가능
5. 같은 상속 계층에 있는 포인터, 레퍼런스 사이의 변환 : dynamic_cast , static_cast
6. 서로 관련없는 포인터, 레퍼런스, 함수 포인터의 변환 : reinterpret_cast

## 11.4 스코프
* 스코프란 유효 범위 이다.
* 스코프 안에 다른 스코프와 같은 이름이 있다면 다른 스코프의 이름을 가린다.

## 11.5 어트리뷰트

### 11.5.1 [[noreturn]]
* 함수가 호출한 쪽으로 리턴을 던지지 않는다는 의미
* 컴파일러는 경고나 에러를 발생시키지 않는다.

### 11.5.2 [[deprecated]]
* 더 이상 지원하지 않는 대상을 지정할 때 사용한다.
* 지원 중단 사유를 인수로 전달할 수 있다.

### 11.5.3 [[fallthrough]] C++17
* switch case 문에서 의도적으로 폴스루를 지정할 때 사용할 수 있다.

### 11.5.4 [[nodiscard]] C++17
* 그 함수를 이용하는 값에서 리턴값을 지정하지 않을 때 경고메시지가 발생한다.


### 11.5.5 [[maybe_unused]] C++17
* 프로그램에서 사용하지 않는 코드를 발견해도 경고메시지를 출력하지 말라고 컴파일러에게 지시



## 11.6 사용자 정의 리터럴
복소수 리터럴을 정의하는 가공 모드 리터럴 연산자를 _i 라는 사용자 정의 리터럴로 구현

std::complex<long double> operator"" _i(long double d)\
{\
&nbsp;&nbsp;&nbsp;&nbsp;return std::complex<long double>(0, d);\
}

그러면 _i 리터럴을 다음과 같이 사용할 수 있다.

std::complex<long double> c1 = 9.634_i;\
auto c2 = 1.23_i;



### 11.6.1 사용자 정의 리터럴에 대한 표준
* s : std::string 리터럴을 생성한다.
* sv : std::string_view 리터럴을 생성한다.
* h, min, s, ms, us, ns : 시간 간격을 표현하는 std::chrono::duration 리터럴을 생성한다.
* i, il, if : 각각 complex\<double>, complex\<long double>, complex\<float> 타입의 리터럴을 생성한다.


## 11.7 헤더 파일
인클루드 가드 : #pragma once

전방 선언 : 헤더 파일에 관련된 문제를 방지하기 위한 또 다른 문제
* 어떤 클래스를 참조해야하는데 그 클래스에 대한 헤더파일을 인클루드할 수 없다면
* 그 클래스가 현재 작성하고 있는 클래스를 너무 많이 의존하고 있다면
* #include 메커니즘으로 불러오지 않고 참조할 수 있다.


## 11.8 C 유틸리티
### 11.8.1 가변 길이 인수 리스트
* ex) printf() 와 같이 가변 길이 함수를 만드는 경우


#include \<cstdio>\
#include \<cstdarg>

bool debug = false;

void debugOut(const char* str, ...) {\
&nbsp;&nbsp;&nbsp;&nbsp;va_list ap;\
&nbsp;&nbsp;&nbsp;&nbsp;if (debug) {\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;va_start(ap, str);\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vfprintf(stderr, str, ap);\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;va_end(ap);\
&nbsp;&nbsp;&nbsp;&nbsp;}\
}

* ... 으로 선언된 인수는 반드시 \<cstdarg>에 정의 된 매크로로 접근해야 한다.
* va_list 타입의 변수를 선언한 뒤
* va_start를 호출하여 초기화한다.
* 가변 인수 리스트를 사용한 뒤
* va_end 를 호출해서 함수의 스택 상태를 일관성 있게 만들어 주어야 한다.

인수에 접근하기
* 실제 인수에 직접 접근하고 싶다면
* va_arg()를 사용한다.

C 스타일의 가변 길이 인수 리스트를 사용하면 안되는 이유
* 매개변수 개수를 알 수 없다.
* 인수 타입을 알 수 없다.