# Chapter 08 클래스와 객체 숙달하기
## 8.2 클래스 작성 방법
### 클래스 멤버
클래스는 여러 개의 멤버를 가질 수 있다.
1. 메서드, 생성자, 소멸자 : 멤버 함수
2. 열거형, 타입 앨리어스, 중첩 클래스 등의 변수 : 멤버 변수
    * 멤버 변수를 데이터 멤버라고 부른다.

정적 멤버 staic member를 제외하면 모두 인트턴스인 객체 단위로 적용된다.

### 접근 제어
클래스의 각 멤버는 세가지 접근 제한자로 지정한다.
* 한 번 지정된 접근 제한자는 다른 지정자로 변경하기 전까지 모든 멤버에 적용된다.

class에서 접근 제한자를 지정하지 않으면 기본적으로 private가 지정된다.
* 구조체는 public이다.

1. public : 어디에서나 접근 가능
2. protected : 같은 클래스, 파생(상속) 클래스만 접근 가능하다.
3. private : 같은 크랠스로만 접근할 수 있다.
    * 모든 데이터 멤버는 private로 지정하자.


### 8.2.2 메서드 정의 방법
데이터 멤버 접근 방법
* 비정적 멤버는 항상 클래스가 아닌 객체에 대해 실행된다.

this 포인터
* 일반 메서드를 호출하면 항상 메서드가 속한 객체의 포인터인 this가 숨겨진 매개변수 형태로 전달된다.
* this 포인터로 해당 객체의 데이터 멤버나 메서드에 접근할 수 있다.

멤버 함수 내부에서 멤버를 정확히 구분할 때 this.value 와 같은 형태로 사용하자.


### 8.2.3 객체 사용법

## 8.3 객체의 라이프 사이클
* 객체의 라이프 사이클은 생성, 소멸, 대입의 세 단계로 구분된다.

### 8.3.1 객체 생성
객체 또한 선언과 동시에 초기화 하는 것이 좋다.
* 이 작업을 생성자라고 부르는 메서드에서 처리할 수 있다.

아무런 인자를 주지 않고 호출하는 생성자 : 디폴트 생성자

명시적 디폴트 생성자

Test() = default;
* 컴파일러에게 디폴트 생성자를 생성하라고 알려주는 것

명시적으로 삭제된 생성자

Test() = delete;
* 컴파일러가 디폴트 생성자를 만들지 않는다.

생성자 이니셜라이저
* 생성자 이니셜라이저를 생성하면 생성과 동시에 객체의 값을 초기화할 수 있다.
* 생성자 내부에서 값을 할당하는 것보다 훨씬 효율적이다.
* 생성자 이니셜라이저는 클래스 정의에 선언된 순서대로 멤버를 초기화한다.


복제 생성자

Test(const Test& test);
* 새로 만들 객체의 데이터 멤버를 모두 기존 객체의 데이터 멤버로 초기화한다.
* 복제 생성자는 생략해도 된다. 컴파일러가 직접 만들어주기 때문

복제 생성자 명시적으로 호출하기

Test test1(3);\
Test test2(test1);
* test1은 test2와 같다.


레퍼런스로 객체 전달하기
* 메서드나 객체를 레퍼런스로 전달하면 복제 연산으로 인한 오버헤드를 줄일 수 있다.
* 레퍼런스 전달 방식을 사용하면 객체의 동적 메모리 할당에 관련된 문제도 피할 수 있다.
* 객체가 변경되지 않도록 const 레퍼런스를 사용하자.

이니셜라이저 리스트 생성자


위임 생성자
* 위임 생성자를 사용하면 같은 클래스의 다른 생성자를 생성자 안에서 호출할 수 있다.
* 위임 생성자는 재귀적으로 호출되지 않도록 주의하자.

### 8.3.2 객체 소멸
* delete로 객체를 소멸 시킬 수 있다.

### 8.3.3 객체에 대입하기
* 어떤 객체의 값을 다른 객체에 대입할 수 있다.
* 복제 대입 연산자를 오버로딩하면 된다.
* 디폴트 대입 연산자를 사용할 수 있다.