# Chapter 12 템플릿으로 제네릭 코드 만들기
C++은 언어 차원에서 객체지향 프로그래밍뿐만 아니라 제네릭 프로그래밍도 지원한다.
* 제네릭 프로그래밍의 목적은 코드를 재사용할 수 있게 하는 것
* C++에서 제네릭 프로그래밍을 위해 제공하는 핵심 도구는 템플릿이다.

## 12.1 템플릿 소개
절차적 프로그래밍 패러다임 : 프로시저나 함수 단위로 프로그램을 작성
* 특정 함수를 하나의 타입만 지원하면 활용도가 떨어짐
* 그래서 그 함수를 매개변수에 값을 지정하기만 하면 실행할 수 있도록 함 : 매개변수화
* 객체 : 데이터와 동작을 하나로 묶은 것

템플릿은 매개변수화 개념을 발전시켜 값 뿐만 아니라 타입에 대해서도 매개변수화


## 12.2 클래스 템플릿
클래스 템플릿은 멤버 변수의 타입, 메서드의 매개변수 또는 리턴 타입을 매개변수로 받아 클래스를 만든다.
* 객체를 저장하는 컨테이너나 데이터 구조에서 주로 사용

클래스 템플릿을 만들면 특정 타입에 종속되지 않게 클래스를 만들 수 있다.
* 클라이언트는 원하는 타입에 맞는 클래스를 인스턴스화해서 사용할 수 있다.
* 이런 방식을 제네릭 프로그래밍이라 한다.

template\<typename T>
* 위 구문을 클래스 선언 앞에 붙이면 클래스를 템플릿 클래스라 선언한 것이다.
* class T 라고도 지정할 수 있다. -> 반드시 class만 올 수 있는 것이 아니다. 모든 타입 가능

템플릿을 정의할 때는 반드시 메서드 구현 코드를 헤더 파일에 적어야 한다.
* 그래야 컴파일러가 템플릿 인스턴스를 생성하기 전 클래스 정의 전체를 알 수 있기 때문


### 12.2.3 컴파일러에서 템플릿을 처리하는 방식
* 템플릿의 처리 과정은 사실 단순하다.
* 단순 반복적인 복사 붙여넣기와 단어 바꾸기 작업을 자동화한 것에 불과

선택적 인스턴스화
* 컴파일러는 항상 제네릭 클래스에 있는 모든 가상 메서드에 대한 코드를 생성한다.
* virtual로 선언하지 않은 다른 메서드는 그중에서 특정 타입에 대해 호출하는 메서드만 컴파일한다.
* 이를 선택적 인스턴스화라고 한다.

템플릿에 사용할 타입의 요건
* 템플릿의 타입 매개변수에 맞게 대입 연산자를 제공해야 한다면 고려할 사항이 많다.
* 선택적 인스턴스화를 통해 그중 일부 메서드를 사용하게 만들면 된다.

### 12.2.4 템플릿 코드를 여러 파일로 나누기
헤더 파일에 템플릿 정의하기
* 메서드 정의 코드를 클래스 정의 코드가 있는 헤더 파일에 함께 적는 방법
* 템플릿 메서드 정의 코드를 다른 헤더 파일에 적고 그 헤더 파일을 클래스 정의 파일에서 #include 하기(반드시 클래스 정의 코드 뒤에)

소스 파일에 템플릿 정의하기
* 소스 파일을 추가하는 #include 문을 적으면 된다. #include "a.cpp"
* 이때 a.cpp 파일이 프로젝트 빌드 목록에 추가되지 않도록 주의한다.
* 메시지 구현 코드가 담긴 파일의 이름은 마음대로 정해도 된다.

클래스 템플릿의 인스턴스화 제한하기
* 마지막에 template class a\<int>;
* 명시적으로 인스턴스화해두면 여기에 나온 타입에 대해서만 빌드한다.


### 12.2.5 템플릿 매개변수
* 템플릿 매개변수를 원하는 수만큼 지정할 수 있다.

비타입 매개변수
* 정수 계열의 타입을 말한다.

타입 매개변수의 디폴트값
* =을 통해 디폴트값을 지정할 수 있다.
* 오른쪽 끝에서 왼쪽으로 중간에 건너뛰지 않고 매개변수를 지정해야 한다.



### 12.2.7 클래스 템플릿의 특수화
* 특정한 경우에 대해서 템플릿을 다르게 구현하는 것

 template<>\
 class Player\<const char*>

 * 이렇게 작성하면 이 클래스가 const char*에 대해 특수화된 Player 클래스라 판단한다.

### 12.2.8 클래스 템플릿 상속하기
* 클래스 템플릿 또한 상속이 가능하다.


### 12.2.9 상속과 특수화 비교

상속
1. 코드 재사용 : O - 파생 클래스는 베이스 클래스의 멤버를 모두 가진다.
2. 이름 재사용 : X - 파생 클래스는 반드시 이름을 다르게
3. 다형성 지원 : O - 파생 클래스의 객체를 베이스 클래스의 객체로 표현할 수 있다.

특수화
1. 코드 재사용 : X - 특수화를 할 때는 모든 코드를 새로 적어야 한다.
2. 이름 재사용 : O - 반드시 원본의 이름과 같아야 한다.
3. 다형성 지원 : X - 템플릿을 인스턴스화한 결과마다 타입이 다 다르다.


### 12.2.10 앨리어스 템플릿
template\<typename T1>\
using OtherName = MyTemplateClass<T1, double>;
* 위와 같이 표현 가능하다.
* typedef로는 표현 불가능하다.