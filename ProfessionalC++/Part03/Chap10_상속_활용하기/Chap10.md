# Chapter 10 상속 활용하기
## 10.1 상속을 이용한 클래스 구현
### 10.1.1 클래스 확장하기
C++에서 클래스를 정의할 때 기존 클래스를 상속, 파생, 확장한다고 한다.
* 이때 원본 클래스를 부모 클래스
* 기존 클래스를 확장한 자식 클래스는 부모 클래스와 다른 부분만 구현하면 된다.

단, 상속은 반드시 한 방향으로만 진행된다.

어떤 객체를 포인터나 레퍼런스로 가리킬 때 
* 파생 클래스 객체도 가리킬 수 있다.
* 다만 반대의 경우는 불가능하다.

파생 클래스 입장에서 본 상속
* 파생 클래스에서 부모 클래스의 protected, public 멤버에 접근할 수 있다.

상속 방지
* 클래스를 정의할 때 final 키워드를 붙이면 다른 클래스가 이 클래스를 상속할 수 없다.

### 10.1.2 메서드 오버라이딩
베이스 클래스에 정의된 메서드의 동작을 변경하는 것

메서드 오버라이딩과 virtual 속성
* C++에서는 베이스 클래스에 virtual 키워드로 선언된 메서드만 오버라이딩 가능하다.

메서드 오버라이딩 문법
* 메서드를 구현할 때는 virtual 키워드를 생략한다.
* 오버라이딩 한 후에는 override 키워드를 붙인다.
* 반드시 적지 않아도 되지만 적는 것을 추천한다.

메서드나 소멸자를 virtual로 지정하면 모든 파생 클래스에서도 virtual 속성을 유지한다.

override 키워드
* 간혹 베이스 클래스에 있는 메서드를 오버라이드하지 않고 virtual 메서드를 새로 정의할 때가 있다.

만약 부모 클래스의 메서드가 인자 타입이 바뀐 경우
* override 를 생략하면 새로운 virtual 함수가 생성된다.
* override를 붙인 경우 컴파일 에러가 발생한다.

virtual 메서드
* virtual로 선언하지 않은 메서드를 오버라이드하면 몇 가지 문제가 생긴다.
* 반드시 오버라이딩할 메서드는 virtual로 선언하자.

오버라이드하지 않고 숨기기
* virtual로 선언하지 않은 메서드를 오버라이드하면 베이스 클래스 정의를 숨겨버린다.
* 오버라이드한 메서드를 파생 클래스 문맥에서만 사용할 수 있게 된다.

Virtual 메서드의 내부 동작 방식
* 메서드가 숨겨지지 않게 하려면 virtual 키워드가 내부적으로 처리되는 과정을 이해해야 한다.

컴파일러는 virtual로 선언되지 않은 메서드를 호출하는 부분을 컴파일 타임에 결정된 타입의 코드로 교체한다.
* 정적 바인딩, 이른 바인딩이라 한다.

virtual로 선언하면 vtable에 특수한 메모리 영역을 활용해서 가장 적합한 구현 코드를 호출한다.
* virtual 메서드가 하나 이상 정의된 클래스마다 vtable을 하나씩 가지게 된다.
* 객체에 대해 메서드를 호출하면 vtable을 보고 그 시점에 적합한 버전을 실행한다.
* 이를 동적 바인딩, 늦은 바인딩이라 부른다.


virtual 소멸자의 필요성
* 소멸자를 virtual로 선언하지 않으면 객체가 소멸할 때 메모리가 해제되지 않을수도 있다.
* 부모 클래스의 소멸자를 호출할 수도 있기 때문

특별한 이유가 없거나 클래스를 final로 선언하지 않았다면 소멸자를 포함한 모든 메서드를 virtual로 선언한다.
* 생성자는 virtual로 선언할 수 없고 그럴 필요도 없다. 객체를 생성할 때 항상 정확한 클래스를 지정하기 때문

오버라이딩 방지하기
* 메서드 또한 final로 지정할 수 있다.

순수 가상 메서드와 추상 베이스 클래스
* 순수 가상 메서드가 최소한 하나라도 정의된 클래스를 추상 클래스라 한다.
* 순수 가상 메서드를 지정하려면 메서드 선언 뒤에 =0을 붙인다.
* 추상 클래스를 상속받은 파생 클래스는 순수 가상 메서드를 하나도 빠짐없이 구현해야 한다.

## 10.5 다중 상속
### 10.5.1 여러 클래스 상속하기
클래스 이름 옆에 상속할 베이스 클래스를 나열하기만 하면 된다.

### 10.5.2 이름 충돌과 모호한 베이스 클래스
모호한 이름
* 부모 클래스 둘이 모두 같은 이름의 메서드를 가지고 있다면 메서드를 오버라이딩 할 수 없다.
* 이름이 같은 메서드를 호출하지 않는다면 문제가 되지 않는다.
* 호출하면 컴파일러가 이름이 모호하다는 에러를 발생시킨다.

모호한 베이스 클래스
* 같은 클래스를 두번 상속할 때 발생한다.

## 10.6 상속에 관련된 미묘하면서 흥미로운 문제들
### 10.6.1 오버라이드한 메서드의 속성 변경하기
리턴 타입 변경하기
* 오버라이드할 메서드는 베이스 클래스의 메서드 프로토타입과 똑같이 작성하는 것이 원칙이다.
* 단, 리턴 타입이 다른 클래스에 대한 포인터나 레퍼런스 타입이면 파생 클래스의 포인터나 레퍼런스 타입으로 바꿀 수 있다.
* 공변 리턴 타입이라 한다.

이 기능은 병렬 계층으로 이뤄진 클래스라면 유용할 수 있다.

메서드 매개변수 변경하기
* 오버라이딩할 때 매개변수를 변경하면 새로운 메서드가 정의된다.

private나 protected로 선언된 베이스 클래스
* private 멤버 메서드 또한 C++에서는 오버라이딩이 가능하다.