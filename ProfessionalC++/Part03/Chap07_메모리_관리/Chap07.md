# Chapter 07 메모리 관리
이 장에서는 메모리의 내부 처리 과정을 다룬다.
* C++ 프로그래머는 메모리를 다루는 코드를 작성할 일이 있기 때문
* 최근에는 로우 레벨 메모리 연산을 최대한 피하는 분위기
* 컨테이너나 스마트 포인터 등의 최신 기능을 선호


## 7.1 동적 메모리 다루기
### 7.1.1 메모리의 작동 과정 살펴보기
로컬 변수 : 자동 변수라고 말하기도 한다.
* automatic variable : 스택에 저장된다.
* 스코프를 벗어나면 자동으로 할당 해제 된다.

new 키워드를 사용하면 힙 메모리가 할당
* int *ptr = new int;
* ptr이라는 변수는 여전히 스택에 있다.
* 하지만 실제 변수가 가리키는 값은 힙에 있다.
* 동적 메모리는 항상 힙에 할당된다.

항상 포인터 변수를 선언하자마자 nullptr이나 적절한 포인터로 초기화해야 한다.
* 절대로 초기화하지 않은 상태로 두면 안된다.

포인터가 스택과 힙에 모두 있는 예

int **handle = nullptr;\
handle - new int*;\
*handle - new int;

* 포인터가 2개 생성된다. handle, *handle
* 이 때 handle은 스택
* *handle은 힙에 구성된다.


### 7.1.2 메모리 할당과 해제
new 와 delete의 사용법
* 변수에 필요한 메모리 블록을 할당하려면 new에 그 변수의 타입을 지정해서 호출한다.
* 이 포인터를 변수에 저장하는 등 관리 작업은 프로그래머의 몫이다.

new의 리턴 값을 무시하거나 그 포인터가 스코프를 벗어나면 할당했던 메모리에 접근할 수 없다.
* 메모리 누수, 메모리 릭(memory leak)

속도가 빠른 메모리를 무한 공급하지 않는 이상\
객체에 할당했던 메모리를 반환하여 다른 용도로 쓸 수 있도록 해야한다.
* delete 연산자를 활용하여 힙 메모리를 할당 해제한다.

new로 메모리를 할당할 때 스마트 포인터가 아닌 일반 포인터라면 delete 문과 짝을 이뤄야 한다.

메모리를 해제한 포인터는 반드시 nullptr로 다시 초기화한다.

malloc
* C++은 여전히 malloc을 지원하지만 new를 사용하는 것이 바람직하다.
* new는 메모리를 할당하는 것을 넘어 객체까지 생성하기 때문이다.

메모리 할당에 실패한 경우
* new 연산자가 항상 성공할 것이라 생각하면 안된다.
* 메모리가 매우 매우 부족하다면 실패하는 상황이 발생할 수 있다.

기본적으로 new가 실패하면 프로그램이 종료된다.

익셉션이 발생하지 않는 new도 있다.
* new(nothrow)
* 이것을 사용하는 경우 nullptr을 체크하는 구문이 필요하다.

### 7.1.3 배열
기본 타입 배열
* 프로그램에서 배열을 할당하면 메모리에서 연속된 공간을 할당한다.

힙에 할당하는 경우 new[]와 delete[]의 짝을 이뤄야 한다.

C++에서는 realloc() 함수 또한 지원한다.
* new로 할당 받은 메모리를 절대 realloc을 사용하여 재할당 하지 마라
* C++에서는 realloc을 절대 사용하지마라, 근처에도 가지 마라

객체 배열
* 객체에 대한 배열도 기본 타입 배열과 비슷하다.
* N개의 객체로 구성된 배열을 new[N]로 할당한 경우 객체를 담기에 충분한 크기의 N개 블록이 연속된 공간에 할당된다.
* 배열의 원소가 객체일 때만 모든 원소에 대해 소멸자가 호출된다.

다차원 스택 배열
* 다차원 스택 배열 또한 연속적인 메모리 공간에 할당된다.

다차원 힙 배열의 경우 스택 배열과 다르다.
* char** board = new char[i][j]; // 컴파일 에러
* 연속적인 공간에 할당되지 않는다. i의 요소는 연속적 j는 떨어져 있다.
* 첫번째 차원의 배열에 char*[]를 선언하고
* 두번째 차원에 배열에 char[]를 할당한다.
* 할당 해제 또한 마찬가지다.


### 7.1.4 포인터 다루기
포인터의 작동 방식
* 포인터를 화살표로 생각하면 이해하기 쉽다.

포인터에 대한 타입 캐스팅
* 포인터의 타입은 C 스타일 캐스팅으로 얼마든지 바꿀 수 있다.
* 정적 캐스팅(static cast)을 사용하면 좀 더 안전하다.
* 그러면 관련 없는 데이터 타입으로 포인터를 캐스팅하면 컴파일 에러가 발생한다.

하지만 상속 관계가 있는 대상끼리 캐스팅할 때는 동적 캐스팅(dynamic cast)를 사용하는 것이 안전하다.

## 7.2 배열과 포인터의 두 얼굴
### 7.2.1 배열=포인터
힙 배열을 참조할 때만 포인터를 사용하는 것이 아니다.
* 배열을 매개변수로 전달하는 과정은 포인터를 매개변수로 전달할 때와 똑같다.
* 배열을 전달하면 레퍼런스 전달 방식과 똑같은 모습을 보인다.

12장에서 자세히 설명할 함수 템플릿을 사용하면 스택 배열의 크기를 컴파일러가 알아낼 수 있다.

### 7.2.2 포인터가 모두 배열은 아니다.

## 7.3 로우레벨 메모리 연산
### 7.3.1 포인터 연산
* string 타입에서 특정 인덱스의 문자만 전달하고 싶을 때 + 연산이 유용
* 같은 타입의 포인터끼리 빼면 두 포인터 사이에 몇 바이트가 있는지 알 수 있다.

### 7.3.2 커스텀 메모리 관리
C++에서 기본으로 제공하는 메모리 할당 기능만으로 대부분의 일이 처리 가능하다.
* new, delete의 내부 처리 과정을 살펴보면
* 메모리를 적절한 크기로 잘라서 전달하고, 현재 메모리에서 사용할 수 있는 공간을 관리하고, 다 쓴 메모리를 해제하는 등 필요한 모든 작업을 수행한다.

리소스가 상당히 부족하거나 메모리 관리와 특수한 작업을 수행할 때 메모리를 직접 다뤄야할 수도 있다.
* 핵심은 클래스에 큰덩어리의 메모리를 할당해놓고 필요할 때 잘라 쓰는 데 있다.

이렇게 직접 관리하면 뭐가 좋을까?
* 오버헤드를 좀 더 줄일 수 있다.
* 여기서 오버헤드란 new로 메모리를 할당하면 얼마나 할당했는지 기록하는 데 필요한 공간을 말한다.
* 이렇게 기록해둬야 delete를 호출할 때 딱 필요한 만큼만 해제할 수 있다.

보통 이 오버헤드는 상당히 작아서 문제가 되진 않지만
* 작은 객체가 많거나 사용하는 객체가 무수히 많을 때는 상당한 영향을 미친다.

메모리를 직접 다룰 때 객체 크기를 사전에 알고 있다면 객체 크기를 관리할 공간을 줄일 수 있다.

### 7.3.3 가비지 컬렉션
메모리를 정상 상태로 유지하기 위한 최후의 보루는 가비지 컬렉션이다.
* C++에서는 지원하지 않는다.
* C++의 스마트 포인터는 가비지 컬렉션과 상당히 비슷한 방식으로 동작한다.

표시 후 쓸기(mark and sweep) : 가비지 컬렉션을 구현하는 기법
1. 모든 포인터를 쉽게 탐색하도록 포인터를 가비지 컬렉터에 리스트 형태로 등록
2. 가비지 컬렉터가 객체의 사용 상태를 표시할 수 있도록 모든 객체가 GarbageCollectible 과 같은 믹스인 클래스를 상속
3. 객체에 동시 접근하지 못하도록 가비지 컬렉터가 작동하는 동안 포인터를 변경할 수 없도록 둠

C++에 안전하고 사용하기 쉬운 가비지 컬렉터를 구현하려는 시도가 많았지만 실패한 이유
* 가비지 컬렉터가 작동하는 동안 프로그램이 멈출 수 있다.
* 소멸자가 비결정적으로 호출된다. 원할 때 소멸자가 호출되지 않는다.


### 7.3.4 객체 풀 (Object Pool)
미리 여유분의 객체를 생성하고 거기서 할당하는 방식
* 매번 객체를 생성하면 오버헤드가 발생하므로 이를 줄이기 위한 방식

## 7.4 스마트 포인터
스마트 포인터는 스코프를 벗어나거나, 리셋되면 리소스가 자동으로 해제 된다.

단독 소유권 방식 : 리소스에 대한 고유 소유권을 받는 것
* 스마트 포인터가 스코프를 벗어나거나 리셋되면 참조하던 리소르를 해제한다.

포인터를 관리하는 과정에서 발생하는 문제는 단순히 스코프를 벗어날 때 해제하는 것을 깜빡하는 상황만 있는 것이 아니다.
* 어떤 포인터의 복사본을 여러 객체나 코드에서 가지고 있을 때가 있다. 앨리어싱(aliasing)
* 리소스를 제대로 해제하려면 가장 마지막에 사용한 포인터가 해제해야 한다.

std::shared_ptr이 레퍼런스 카운팅을 이용하여 공유 소유권 방식을 지원한다.
* C++ 표준에서 shared_ptr은 스레드에 안전하다. 
* 포인터가 가리키던 리소스가 스레드에 안전하다는 것은 아니다.

### 7.4.1 unique_ptr
unique_ptr을 생성하는 방법
* auto ptr = make_unique\<Test>(); : C++14 부터 가능
* unique_ptr\<Test> ptr(new Test()); : make_unique 지원 안한다면

unique_ptr의 사용 방법

get 메서드를 이용하면 내부 포인터에 직접 접근할 수 있다.
* 일반 포인터만 전달 받는 함수에 유용

reset을 사용하면 unique_ptr의 내부 포인터를 해제하고 다른 포인터로 교체 가능하다.

uPtr.reset(); // 해제 후 nullptr로 초기화\
uPtr.reset(new Test()); // 리소스 해제 후 새로운 Test 인스턴스로 설정

release를 이용하면 unique_ptr과 내부 포인터의 관계를 끊을 수 있다.

Test *uPtr = prevUPtr.release();
* 스마트 포인터는 리소스의 소유권을 잃으며, 리소스를 다 쓴 뒤 직접 해제해야 한다.

unique_ptr은 단독 소유권을 표현하기 때문에 복사할 수 없다.
* std::move를 사용하면 unique_ptr을 다른 곳으로 이동 가능
* 복사 보다는 이동의 개념

### 7.4.2 shared_ptr
shared_ptr은 make_shared()로 생성한다.

auto sPtr = make_shared\<Test>();
* shared_ptr을 생성할 때는 반드시 make_shared로 생성한다.

shared_ptr 또한 get과 reset 메서드를 제공한다.
* reset 메서드를 호출하면 레퍼런스 카운팅을 감소시킨다.

shared_ptr 캐스팅하기
* const_pointer_cast
* dynamic_pointer_cast
* static_pointer_cast
* reinterpret_pointer_cast : C++17 부터

레퍼런스 카운팅이 필요한 이유
* 스마트 포인터가 중복 삭제되는 문제를 방지
* 일반 포인터로 2개의 스마트 포인터를 만들면 : 소멸자가 2번 호출된다.
* 무조건 shared_ptr은 make_shared로 만들자.

unique_ptr은 레퍼런스 카운팅을 지원하지 않는다.

### 7.4.3 weak_ptr
weak_ptr은 shared_ptr이 가리키는 리소스 레퍼런스 관리에 사용된다.
* weak_ptr에 저장된 포인터는 shared_ptr로 변환하여 접근해야 접근 가능하다.
* weak_ptr의 lock 메서드를 이용하여 shared_ptr을 리턴 받아 사용한다.
* 이 때 shared_ptr에 연결된 weak_ptr이 해제되면 nullptr이 된다.
* shared_ptr만 사용하면 순환 참조 문제가 발생할 수 있어 weak_ptr을 사용한다.
* shared_ptr의 생성자에 weak_ptr를 인수로 전달하여 shared_ptr을 새로 생성한다. 이 때 shared_ptr에 연결된 weak_ptr이 해제되면 std::bad_weak_ptr 익셉션이 발생한다.

C++17 부터 weak_ptr도 C 스타일 배열을 지원한다.

### 7.4.4 이동 의미론
표준 스마트 포인터는 모두 이동 의미론을 지원한다. : 성능 향상을 위해
* 이동 의미론을 이용하면 스마트 포인터를 리턴하는 과정을 매우 효율적으로 처리할 수 있다.

### 7.4.5 enable_shared_from_this
* std::enable_shared_from_this를 사용하면 스마트 포인터를 안전하게 리턴할 수 있다.
* return shared_from_this();를 통해 shared_ptr를 반환할 수 있다.
* weak_from_this() : weak_ptr를 반환한다. C++17

### 7.4.6 현재는 폐기된 auto_ptr
* 컨테이너에서 제대로 동작하지 못한다.
* C++17에서 완전히 삭제되었고 unique_ptr과 shared_ptr로 완전히 대체되었다.


## 7.5 흔히 발생하는 메모리 문제
1. 스트링 과소 할당 문제
2. 메모리 경계 침범
3. 메모리 누수
4. 중복 삭제와 잘못된 포인터

비주얼 C++를 이용한 윈도우 애플리케이션의 메모리 누수 탐지 및 수정 방법

이 기능을 사용하려면 코드 첫머리에 세 문장을 추가한다.

#define _CRTDBG_MAP_ALLOC\
#include /<cstdlib>\
#include /<crtdbg.h>

new 연산자를 다음과 같이 새로 정의한다.

#ifdef _DEBUF\
#ifndef DBG_NEW\
#define DBG_NEW new ( _NORMAL_BLOCK, /_/_FILE__, /_/_LINE__)

마지막으로 main() 함수의 첫 부분에 다음 문장을 추가한다.

_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

여기까지 완료하면 애플리케이션이 종료할 때 비주얼 C++의 CRT 라이브러리는 현재 감지된 모든 메모리 누수 현상을 디버그 콘솔에 출력한다.
* 어느 파일의 몇 번 줄에서 누수가 발생했는지 표시한다.


_CrtSetBreakAlloc() 함수를 호출하면 몇번째 메모리를 할당하는 지점에 실행을 중단하고 디버거를 구동한다.
